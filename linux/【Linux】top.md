## Linux top命令详解
top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器

### 命令样例
```
top - 11:08:44 up 16:58,  6 users,  load average: 1.62, 2.07, 2.04
Tasks: 2853 total,   2 running, 2847 sleeping,   0 stopped,   4 zombie
%Cpu(s):  6.3 us,  3.4 sy,  0.0 ni, 86.4 id,  3.8 wa,  0.0 hi,  0.1 si,  0.0 st
KiB Mem : 34779136 total,  6823344 free, 24735868 used,  3219924 buff/cache
KiB Swap:        0 total,        0 free,        0 used.  8963864 avail Mem 

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                                                                                   
33509 root      20   0 2965096 290884  38468 S  14.4  0.8 189:23.96 kubelet                                                                                                                                                                   
36626 root      20   0  9.811g 207160   4156 S  11.8  0.6 127:57.66 beam.smp                                                                                                                                                                  
21699 root      20   0 12.355g 266000  17008 S   5.2  0.8  94:03.32 dockerd-current                                                                                                                                                           
34545 root      20   0 1926476 562756  18068 S   2.6  1.6  48:29.14 hyperkube                                                                                                                                                                 
38574 root      20   0   59948   5584   2256 D   2.3  0.0   0:00.07 lvs                                                                                                                                                                       
30091 root      20   0 10.381g 211448  41560 S   2.0  0.6  37:30.99 etcd                                                                                                                                                                      
18337 root      20   0  228756  65096   6520 S   1.6  0.2  16:47.89 st2notifier                                                                                                                                                               
34040 root      20   0  160624   5148   1548 R   1.6  0.0   0:00.22 top
```

### top信息解释
**第一行，任务队列信息，同 uptime 命令的执行结果**
 - 系统时间：11:08:44
 - 运行时间：up 16:58
 - 当前登录用户：6 users
 - 负载均衡(uptime) load average: 1.62, 2.07, 2.04
   * average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。
   * 平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数
   * 可运行状态：指正在使用CPU或者正在等待CPU的进程，也就是我们常用ps aux命令看到的处于R(running,runnable)状态的进程。
   * 不可中断状态：指进程正处于内核态关键流程中的进程，并且这些流程是不可被打断的，比如最长久的是等待硬件设备的I/O响应，也就是我们在ps aux命令中看到的D(Uniterruptible,Disk Sleep)状态的进程。
   * 比如，当一个进程向磁盘写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程就处于不可中断状态，如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。所以，不可中断状态，实际上是系统对进程和硬件设备的一种保护机制。
   * load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了


**第二行，Tasks — 任务（进程）**  这里到底是进程数还是线程数？？？
 - 总进程:2853 total, 运行:2 running, 休眠:2847 sleeping, 停止: 0 stopped, 僵尸进程: 4 zombie

**第三行，cpu状态信息**
 - 6.3%us【user space】— 用户空间占用CPU的百分比。
 - 3.4%sy【sysctl】— 内核空间占用CPU的百分比。
 - 0.0%ni【】— 改变过优先级的进程占用CPU的百分比
 - 86.4%id【idolt】— 空闲CPU百分比
 - 3.8%wa【wait】— IO等待占用CPU的百分比
   *  iowait 表示任务中有等待 I/O 操作完成的时间。
 - 0.0%hi【Hardware Interrupts】— 硬中断占用CPU的百分比
 - 0.1%si【Software Interrupts】— 软中断占用CPU的百分比
 - 0.0%st【】— 软

**第四行,内存状态**
 - 34779136 total,  6823344 free, 24735868 used,  3219924 buff/cache【缓存的内存量】

**第五行，swap交换分区信息**
 - 0 total,        0 free,        0 used.  8963864 avail Mem【缓冲的交换区总量】

**第六行，空行**

**第七行以下：各进程（任务）的状态监控**
 - PID — 进程id
 - USER — 进程所有者
 - PR — 进程优先级
 - NI — nice值。负值表示高优先级，正值表示低优先级
 - VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
   * 进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据等
   * 假如进程申请100m的内存，但实际只使用了10m，那么它会增长100m，而不是实际的使用量
 - RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
   * 进程当前使用的内存大小，但不包括swap out
   * 包含其他进程的共享
   * 如果申请100m的内存，实际使用10m，它只增长10m，与VIRT相反
   * 关于库占用内存的情况，它只统计加载的库文件所占内存大小
 - SHR — 共享内存大小，单位kb
   * 除了自身进程的共享内存，也包括其他进程的共享内存
   * 虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小
   * 计算某个进程所占的物理内存大小公式：RES – SHR
   * swap out后，它将会降下来
 - S —进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程
 - %CPU — 上次更新到现在的CPU时间占用百分比
 - %MEM — 进程使用的物理内存百分比
 - TIME+ — 进程使用的CPU时间总计，单位1/100秒
 - COMMAND — 进程名称（命令名/命令行）

**top 运行中可以通过 top 的内部命令对进程的显示方式进行控制。内部命令如下：**
 - s – 改变画面更新频率
 - l – 关闭或开启第一部分第一行 top 信息的表示
 - t – 关闭或开启第一部分第二行 Tasks 和第三行 Cpus 信息的表示
 - m – 关闭或开启第一部分第四行 Mem 和 第五行 Swap 信息的表示
 - N – 以 PID 的大小的顺序排列表示进程列表
 - P – 以 CPU 占用率大小的顺序排列进程列表
 - M – 以内存占用率大小的顺序排列进程列表
 - h – 显示帮助
 - n – 设置在进程列表所显示进程的数量
 - q – 退出 top
 - s – 改变画面更新周期

**占用内存的测量**

测量一个进程占用了多少内存，linux为我们提供了一个很方便的方法，/proc目录为我们提供了所有的信息，实际上top等工具也通过这里来获取相应的信息。
* /proc/meminfo 机器的内存使用信息
* /proc/pid/maps pid为进程号，显示当前进程所占用的虚拟地址。
* /proc/pid/statm 进程所占用的内存


### 使用方法
#### 使用格式
top [-] [d] [p] [q] [c] [C] [S] [s] [n]

#### 参数说明
 - d：指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。
 - p:通过指定监控进程ID来仅仅监控某个进程的状态。
 - q:该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。
 - S：指定累计模式。
 - s：使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。
 - i：使top不显示任何闲置或者僵死进程。
 - c:显示整个命令行而不只是显示命令名。

#### 常用命令

* 查看top显示所有进程
  top -bn1

* 查看多核CPU命令
  
  mpstat -P ALL  和  sar -P ALL 
  说明：sar -P ALL > aaa.txt   重定向输出内容到文件 aaa.txt

* top 命令，然后按数字“1”可监控每个逻辑CPU的状况：
```
top - 13:56:21 up 19:46,  6 users,  load average: 2.14, 2.76, 2.97
Tasks: 3232 total,   2 running, 3222 sleeping,   0 stopped,   8 zombie
%Cpu0  : 10.3 us,  2.6 sy,  0.0 ni, 86.8 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu1  : 10.4 us,  3.6 sy,  0.0 ni, 86.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu2  :  8.9 us,  4.0 sy,  0.0 ni, 85.8 id,  0.7 wa,  0.0 hi,  0.7 si,  0.0 st
%Cpu3  :  8.3 us,  4.5 sy,  0.0 ni, 87.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu4  :  6.9 us,  3.0 sy,  0.0 ni, 90.2 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu5  :  4.9 us,  2.6 sy,  0.0 ni, 92.1 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu6  :  6.0 us,  1.0 sy,  0.0 ni, 93.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu7  :  3.3 us,  5.6 sy,  0.3 ni, 90.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu8  :  3.6 us,  4.3 sy,  0.0 ni, 91.7 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu9  :  7.0 us,  1.3 sy,  0.0 ni, 91.1 id,  0.3 wa,  0.0 hi,  0.3 si,  0.0 st
%Cpu10 :  4.0 us,  0.7 sy,  0.0 ni, 95.4 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu11 :  4.0 us,  1.7 sy,  0.0 ni, 92.7 id,  1.3 wa,  0.0 hi,  0.3 si,  0.0 st
%Cpu12 :  5.0 us,  2.0 sy,  0.0 ni, 92.7 id,  0.0 wa,  0.0 hi,  0.3 si,  0.0 st
%Cpu13 :  4.6 us,  1.6 sy,  0.0 ni, 93.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu14 :  2.3 us,  1.0 sy,  0.0 ni, 96.0 id,  0.7 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu15 :  7.3 us,  2.0 sy,  0.0 ni, 90.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem : 34779136 total,  5564532 free, 27106152 used,  2108452 buff/cache
KiB Swap:        0 total,        0 free,        0 used.  6467812 avail Mem
```

* mpstat -P ALL
```
Linux 3.10.0-693.11.1.el7.es.10.x86_64 (node-1.domain.tld) 	2020年06月16日 	_x86_64_	(16 CPU)

14时01分34秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
14时01分34秒  all    7.07    0.04    2.95    2.02    0.00    0.15    0.01    0.00    0.00   87.75
14时01分34秒    0    8.77    0.04    4.30    1.48    0.00    0.17    0.01    0.00    0.00   85.23
14时01分34秒    1    9.39    0.04    4.28    1.73    0.00    0.12    0.01    0.00    0.00   84.43
14时01分34秒    2   13.41    0.04    4.06    1.97    0.00    0.91    0.02    0.00    0.00   79.60
14时01分34秒    3    8.14    0.03    3.66    1.80    0.00    0.09    0.01    0.00    0.00   86.26
14时01分34秒    4    6.96    0.04    2.94    1.91    0.00    0.08    0.01    0.00    0.00   88.04
14时01分34秒    5    6.40    0.03    2.62    1.96    0.00    0.09    0.01    0.00    0.00   88.89
14时01分34秒    6    6.18    0.04    2.57    2.01    0.00    0.08    0.01    0.00    0.00   89.11
14时01分34秒    7    6.20    0.04    2.53    1.92    0.00    0.07    0.01    0.00    0.00   89.23
14时01分34秒    8    6.09    0.04    2.52    1.93    0.00    0.08    0.01    0.00    0.00   89.34
14时01分34秒    9    5.99    0.04    2.49    1.95    0.00    0.07    0.01    0.00    0.00   89.45
14时01分34秒   10    5.88    0.04    2.46    1.93    0.00    0.07    0.01    0.00    0.00   89.60
14时01分34秒   11    6.07    0.04    2.74    3.84    0.00    0.18    0.01    0.00    0.00   87.11
14时01分34秒   12    5.78    0.04    2.61    2.10    0.00    0.17    0.01    0.00    0.00   89.29
14时01分34秒   13    5.78    0.04    2.44    1.91    0.00    0.07    0.01    0.00    0.00   89.75
14时01分34秒   14    6.12    0.04    2.49    1.96    0.00    0.14    0.02    0.00    0.00   89.23
14时01分34秒   15    5.75    0.04    2.46    1.97    0.00    0.07    0.01    0.00    0.00   89.70
```

* sar -P ALL
同 mpstat -P ALL ，内容更详细


### Linux查看物理CPU个数、核数、逻辑CPU个数
总核数 = 物理CPU个数 X 每颗物理CPU的核数 
总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数

* 查看物理CPU个数

cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l

* 查看每个物理CPU中core的个数(即核数)

cat /proc/cpuinfo| grep "cpu cores"| uniq

* 查看逻辑CPU的个数

cat /proc/cpuinfo| grep "processor"| wc -l

* 查看CPU信息（型号）

cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c

* 查看内存信息

cat /proc/meminfo

### 平均负载与CPU使用率
平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数，所以，他不仅包扩了正在使用CPU的进程，还包括等待CPU和等待I/O的进程。
而CPU使用率，是单位时间内CPU繁忙情况的统计，和平均负载并不一定完全对应。比如：

* CPU密集型进程，使用大量CPU会导致平均负载升高，此时这两者是一致的。
* I/O 密集型进程， 等待I/O也会导致平均负载升高，但是CPU使用率不一定很高。
* 大量等待CPU的进程调用也会导致平均负载升高，此时的CPU使用率也会比较高。

### 平均负载案例分析
这里会用到2个工具，stress和sysstat
* stress是一个Linux系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景。
* sysstat是一个linux性能工具，用来监控和分析系统的性能，以下案例中会用到这个包的2个命令mpstat和pidstat。
  - mpstat 是一个常用的多核CPU性能分析工具用来实时查看每个CPU的性能指标，一级所有CPI的平均指标。
  - pidstat 是一个常用的进程性能分析工具，用来实时查看进程的CPU、内存、I/O以及上下文切换等性能指标。
