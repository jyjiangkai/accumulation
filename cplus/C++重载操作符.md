## C++重载操作符
operator是C++的关键字，它和运算符一起使用，表示一个运算符函数，理解时应将operator=整体上视为一个函数名。

###为什么使用操作符重载
对于系统的所有操作符，一般情况下，只支持基本数据类型和标准库中提供的class，对于用户自己定义的class，如果想支持基本操作，比如比较大小，判断是否相等，等等，则需要用户自己来定义关于这个操作符的具体实现。比如，判断两个人是否一样大，我们默认的规则是按照其年龄来比较，所以，在设计person这个class的时候，我们需要考虑操作符==，而且，根据刚才的分析，比较的依据应该是age。那么为什么叫重载呢？这是因为，在编译器实现的时候，已经为我们提供了这个操作符的基本数据类型实现版本，但是现在他的操作数变成了用户定义的数据类型class，所以，需要用户自己来提供该参数版本的实现。

###如何声明重载操作符
####操作符重载实现为类成员函数
重载操作符在类体中被声明，声明方式如同普通成员函数一样，只不过他的名字包含关键字operator，以及紧跟其后的一个c++预定义的操作符。
可以用如下的方式来声明一个预定义的==操作符:
声明方式如下：
class person{
    public:
        person(int a)
        {
            this->age=a;
        }
        bool operator == (const person &ps) const;
    private:
        int age;
};
实现方式如下：
bool person::operator == (const person &ps) const
{
    return (this->age==ps.age);
}
调用方式如下：
#include
using namespace std;
int main()
{
    person p1(10);
    person p2(20);
    if (p1 == p2)
    {
        cout<<”the age is equal!”<<endl;
    }
    return 0;
}

这里，因为operator==是class person的一个成员函数，所以对象p1,p2都可以调用该函数，上面的if语句中，相当于p1调用函数==，把p2作为该函数的一个参数传递给该函数，从而实现了两个对象的比较。

####操作符重载实现为非类成员函数(全局函数)
对于全局重载操作符，代表左操作数的参数必须被显式指定。例如：
#include
using namespace std;
class person
{
    public:
        int age;
};

bool operator==(person const &p1 ,person const & p2)  //满足要求，做操作数的类型被显示指定
{
    return (p1.age==p2.age);
}

int main()
{
    person rose;
    person jack;
    
    rose.age=18;
    jack.age=23;

    if (rose == jack)
    {
        cout<<"rose == jack"<<endl;
    }
     return 0;
}

####如何决定把操作符重载为类成员函数还是全局函数
(1)如果重载操作符是类成员，那么只有当与他一起使用的左操作数是该类的对象时，该操作符才会被调用。如果该操作符的左操作数必须是其他的类型，则操作符必须被重载为全局函数。
(2)C++要求赋值=，下标[]，调用()，和成员指向-> 操作符必须被定义为类成员操作符。任何把这些操作符定义为全局函数的定义都会被标记为编译错误。
(3)如果有一个操作数是类类型，如string类的情形，那么对于对称操作符比如“==”操作符最好定义为全局函数。

####重载操作符的限制：
(1)只有C++预定义的操作符才可以被重载；
|+	  |-	  |*	  |/	  |%	  |^  	|&	  ||	  |~	  |
|!	  |,	  |=	  |<	  |>	  |<=	  |>=	  |++	  |--	  |
|<< 	|>>	  |==	  |!=	  |&&	  |||	  |+=	  |-=	  |/=	  |
|%= 	|^=	  |&=	  ||= 	|*=	  |<<=?	|>>=	|[]	  |()	  |
|->	  |->*	|new	|new[]|delete	    |delete[]	  |	    |
(2)对于内置类型的操作符，它的预定义不能被改变，不能为内置类型重载操作符，如，不能改变int型的操作符+的含义；
(3)不能为内置的数据类型定义其它的操作符；
(4)只能重载类类型或枚举类型的操作符；
(5)重载操作符不能改变它们的操作符优先级；
(6)重载操作符不能改变操作数的个数；
(7)除了对()操作符外，对其他重载操作符提供缺省实参都是非法的；

####注意点
(1)重载操作符首先要确定它的返回值是左值，还是右值，如果是左值则返回引用，如果是右值那就直接返回值；
(2)+号等这样的操作符没有对象可以容纳改变后值，对于这样的情况最好返回数值，否则只能要操作符体内创建临时对象用于容纳改变后的值，如果在堆中创建临时对象返回指针或者引用，在操作符函数体外还需要释放它，如果返回的对象而不是引用或者指针，那么效率是比较低的。如果返回的是数值，最好在该类的构造函数中增加对该类型数值的转换函数，如：返回值是int类型，那么最好有一个int类型作为参数的构造函数。
(3)在增量运算符中，放上一个整数形参，就是后增量运行符，它是值返回，对于前增量没有形参，而且是引用返回，示例：
class Test
{
    public:
        Test(x=3){ m_value = x}
        Test &operator ++();   //前增量
        Test &operator ++(int);//后增量
    private:
        int m_value:
};
Test &Test::operator ++()
{
    m_value ++;    //先增量
    return *this;  //返回当前对象
}
Test Test::operator ++(int)
{
    Test tmp(*this);  //创建临时对象
    m_value ++;       //再增量
    return tmp;       //返回临时对象
}
(4)强制转换是针对基本数据类型的，对类类型的转换需自定义；
(5)转换运行符重载声明形式：
operator 类型名();它没有返回类型，因为类型名就代表了它的返回类型，所以返回类型显得多余。
(6)一般来说，转换运算符与转换构造函数（即带一个参数的构造函数）是互逆的，如有了构造函数Test(int)，那么最好有一个转换运算符int()。这样就不必提供对象参数重载运算符了，如Test a1(1);Test a2(2);Test a3; a3 = a1+a2;就不需要重载+号操作符了，因为对于a1+a2的运算，系统可能会先找有没有定义针对Test的+号操作符，如果没有，它就会找有没有针对Test类转换函数参数类型的+号操作符（因为可以将+号运行结果的类型通过转换函数转换为Test对象），因为Test类有个int类型的参数，对于int类型有+操作符，所以a1+a2真正执行的是Test(int(a1) + int(a2));即Test(3)；
(7)对于转换运算符，还有一个需要注意的地方就是，如果A类中有以B为参数的转换函数(构造函数)，那B中不能有A的转换运算符，不然就存在转换的二义性，如：
class A{A(B&){…}}; class B{operator A(){…}};
那么以下语句就会有问题：
B b; A(b);//A(b)就有可能是A的构造函数，也可能是B的转换运算符
