//C++相关
##C++继承
继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。也达到了重用代码功能和提高执行时间的效果。
当创建一个类时，不需要重新编写新的数据成员和成员函数，只需要制定新建的类继承了一个已有的类的成员即可。这个已有的类成为基类，新建的类成为派生类。

一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来制定基类。类派生列表以一个或多个基类命名。
`class 派生类类名：继承类型 基类类名`
派生类可以访问基类中所有的非私有成员。

一个派生类继承了所有的基类方法，但下列情况除外：
*基类的构造函数、析构函数和拷贝构造函数；
*基类的重载运算符；
*基类的友元函数。

####继承类型
我们几乎不使用protected或private继承，通常使用public继承。当使用不用类型的继承时，遵循以下几个规则：
1、公有继承（public）：当一个类派生自共有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。
2、保护继承（protected）：当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。
3、私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。

##C++重载运算符和重载函数
实际上就是定义两个函数名相同的函数，但是参数的类型或者个数不相同，使用的时候会自动匹配最合适的函数进行调用。

##C++多态
在基类Shape类中，area()的声明前放置关键字virtual。
有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至是可以相同的。

####虚函数
虚函数是在基类中使用关键字virtual声明的函数。在派生类中中心定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数。这种操作被称为动态链接，或后期绑定。

####纯虚函数
你可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这时候就会用到纯虚函数。
纯虚函数写法：
//pure virtual funtion
virtual int area() = 0;  // = 0告诉编译器，函数没有主体，该虚函数是纯虚函数。

##C++数据抽象
数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。
数据抽象是一种依赖于接口和实现分离的编程(设计)技术。
数据抽象的好处：
1、类的内部受到保护，不会因无意的用户级错误导致对象状态受损。
2、类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对安歇要求不改变用户级代码的错误报告。

##数据封装
数据封装是一种把数据和操作数据的函数捆绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。
为了使类中的成员变成公有的(即程序中的其他部分也能访问)，必须在这些成员前使用public关键字进行声明。所有定义在public标识符后面的变量或者函数可以被程序中所有其他的函数访问。【即为友元函数】

##C++接口(抽象类)
接口描述了类的行为和功能，而不需要完成类的特定实现。
C++接口是使用抽象类来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。
如果类中至少有一个函数被声明为纯虚函数，这这个类就是抽象类。纯虚函数是用户在声明使用“=0”来指定的。

##C++文件和流

##C++异常处理
异常时程序在执行期间产生的问题。C++异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。
异常提供了一种转移程序控制权的方式。C++异常处理涉及到三个关键字：try、catch、throw。
throw：当问题出现时，程序会抛出一个异常，这是通过使用throw关键字来完成的。
catch：当您想要处理问题的地方，通过异常处理程序捕获异常。catch关键字用于捕获异常。
try：try块中的代码标识将被激活的特定异常。它后面通常跟着一个或者多个catch块。

##C++动态内存
C++程序中的内存分为两个部分：
栈：在函数内部声明的而所有变量都讲占用栈内存
堆：这是程序中未使用的内存，在程序运行时可用于动态内存分配
很多时候，您无法提前预支需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。在C++中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即new运算符。

##C++命名空间

##C++模板
####函数模板
template <typename T>
inline T const& Max(T const& a, T const& b)
{
	return a<b?b:a;
}

####类模板
template <class T>
class Stack { 
  private: 
    vector<T> elems;     // 元素 
 
  public: 
    void push(T const&);  // 入栈
    void pop();               // 出栈
    T top() const;            // 返回栈顶元素
    bool empty() const{       // 如果为空则返回真。
        return elems.empty(); 
    } 
}; 
 
template <class T>
void Stack<T>::push (T const& elem) 
{ 
    // 追加传入元素的副本
    elems.push_back(elem);    
} 
 
template <class T>
void Stack<T>::pop () 
{ 
    if (elems.empty()) { 
        throw out_of_range("Stack<>::pop(): empty stack"); 
    }
    // 删除最后一个元素
    elems.pop_back();         
} 
 
template <class T>
T Stack<T>::top () const 
{ 
    if (elems.empty()) { 
        throw out_of_range("Stack<>::top(): empty stack"); 
    }
    // 返回最后一个元素的副本 
    return elems.back();      
} 

##C++预处理器
预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。
所有的预处理器指令都是以井号(#)开头，指示空格字符可以出现在预处理指令之前。预处理指令不是C++语句，所以它们不会以分号(;)结尾。
#define 预处理
#define预处理指令用于创建符号常量。该符号常量通常称为宏。
函数宏：#define MIN(a,b) (((a)<(b))?a:b)

条件编译：
`#if、#else、#endif、#ifndef、#ifdef`

`#和##运算符`
`#运算符会把#后面的内容转换为用引号引起来的字符串`
`##运算符会把##前后的内容连接起来`

##C++信号处理

##C++多线程

































