##查找与排序算法

####哈希查找
通过建立元素关键字与存放位置的对应关系实现查找的新方法就是我们本节所要介绍的哈希查找。

hashmap和map

STL
####插入排序
插入排序是通过将未排序部分的记录逐个按其关键字大小插入已排好序部分的恰当位置，最终实现全部记录有序排序的排序方法。
void InsertSort(SeqList* L)
{
	int i,j,n;
	n = L->length;
	for(i=2;i<=n;i++)/* 外循环控制排序的总趟数 */
	{
		L->list[0] = L->list[i];
		j = i - 1;
		while(L->list[0].key < L->list[j].key) /* 在有序表中寻找插入位置 */
		{
			L->List[j+1] = L->list[j];
			j--;
		}
		L->list[j+1] = L->list[0];
	}
}

####冒泡排序
将n个记录看作按纵向排列，每趟排序时自下而上对每对相邻记录进行比较，若次序不符合要求(逆序)就交换。
void BubbleSort(SeqList* L)
{
	int i,j,n,flag;
	DataType temp;
	n = L->length;
	flag = 1;
	i = 1;
	while((i < n)&&(flag == 1)/* 外循环控制排序的总趟数 */
	{
		flag = 0;
		for(j=n;j>i;j--)
		{
			if (L->list[j].key < L->list[j-1].key)/* 相邻元素进行比较，若逆序就交换 */
			{
				flag = 1;
				temp = L->list[j];
				L->list[j] = L->list[j-1];
				L->list[j-1] = temp;
			}
		}
		i++;
	}
}

####快速排序
通过把数据表中的第一个记录放到表中恰当位置上，将原表划分为两个子表，同时对其他记录进行适当调整，使得前面子表中记录的关键字值均小于此记录的关键字值，后面子表中记录的关键字值均大于此记录的关键字值。接着再对两个子表分别进行这样的操作，递归执行此过程，知道各子表长度都小于等于1，此时数据表就已经有序排列了。
int QuickPass(DataType list[], int low, int high)  /* 对表list[low]~list[high]进行一次划分 */
{
	int i,j;
	DataType x;
	i = low;
	j = high;  /* i指示扫描区间的左端，j指示扫描区间的右端 */
	x = list[i];  /* x用于存放划分基准元素，即表中的第一个元素 */
	while(i!=j)  /* 重复向左向右扫描，直至找打划分点，即i和j重合的位置 */
	{
		while((list[j].key >= x.key)&&(i<j))  /* 从右向左扫描 */
		{
			j--;
		}
		if(i<j)  /* 若发现小于x.key的元素，将其放到前面的子表中并改变扫描方向 */
		{
			list[i] = list[j];
			i++;
		}
		while((list[i].key <= x.key)&&(i<j))  /* 从左向右扫描 */
		{
			i++;
		}
		if(i<j)  /* 若发现大于x.key的元素，将其放到前面的子表中并改变扫描方向 */
		{
			list[j] = list[i];
			j--;
		}
	}
	list[i] = x;  /* 将基准元素插入划分点位置，完成一次划分 */
	return i;  /* 返回划分点位置 */
}

void QuickSort(DataType list[], int s, int t)  /* 对表list[s]~list[t]进行快速排序 */
{
	int i;
	if(s<t)  /* 只要排序区间中的元素超过1个，继续进行快速排序 */
	{
		i = QuickPass(list, s, t);  /* 对表list[s]~list[t]进行一次划分 */
		QuickSort(list, s, i-1);  /* 对划分得到的两个子表继续进行快速排序 */
		QuickSort(list, i+1, t);
	}
}

####选择排序
选择排序是通过每一趟排序过程中从待排序记录中选择出关键字最小(大)的记录，将其一次放在数据表的最前或最后端的方法来实现整个数据表的有序排列。
void SelectSort(SeqList* L)
{
	int i, j, k, n;
	DataType temp;
	n = L->length;
	for(i=1;i<=n-1;i++)  /* 外循环控制排序的总趟数 */
	{
		k = i;
		for(j=i+1;j<=n;j++)  /* 在待排序范围内寻找关键字最小的记录 */
		{
			if(L->list[j].key < L->list[k].key)
			{
				k = j;
			}
		}
		if(k!=j)
		{
			temp = L->list[i];
			L->list[i] = L->list[k];
			L->list[k] = temp;
		}
	}
}

####递归排序
首先将待排序的n个记录看作n个长度为1的有序子表，然后从第一个子表开始，对相邻的子表进行两两合并，接着再对合并后的有序子表继续进行两两合并，重复以上的合并工作，知道得到一个长度为n的有序表。