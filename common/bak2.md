【【【重要】】】
##重绘和回流的区别
##http协议先关的：http和https区别、post请求实体头部的参数，常见的请求类型，除了get和post还有哪些
##Css如何实现垂直水平居中（两种方案）
##webpack配置相关
##react当中setState函数执行机制（主要是什么时候会立即改变，什么时候不会）
##编程题，高阶函数的实现
##BFC概念理解
##es6 promise回调执行时间

#数据结构和算法
##链表、hashmap、b树......
##指定一个场景，考察算法选择和设计
##两个链表做加法
如
链表1：1->3->4
链表2：   2->6
相加后得到：
链表3：1->5->0 （不考虑进位）
链表4：1->6->0 （考虑进位）

#问答题
##linux开机启动流程
##网络服务调用如何保证幂等性
##对比memcache、redis性能、功能和应用场景
##mysql调优方案

#基础题
##TCP协议，动态规划等，重点考察数据结构和算法，分布式理论相关和解决问题的能力
##找出二叉树和无向图任意两个节点间的最大距离（代码实现）
##使用stack实现queue（代码实现）
##Raft协议、Paxos、Zap协议的区别。详细描述raft协议
##HBase的内部数据存储结构
##Redis中zset在项目中怎么使用的，zset的实现方式，如果让你来实现一个zset会怎么实现
##bloom filter实现原理，以及在HBase中的使用
##Kafka在什么情况下会丢失数据，在什么情况下会乱序
##Hadoop中熟悉什么组件，分别介绍一下架构和应用场景
##介绍自己比较擅长什么，举两个例子（技术方面）

#算法题
##有k个已排序数组，元素可能会重复，求所有元素的中位数和时间复杂度
int selectMid(const vector<vector<int>> &nums)

#基础题
##MySQL的底层数据结构是什么？B+数和红黑树的区别？为啥不用红黑树？如果索引是全内存，不写磁盘B+数还有优势吗？
##select id form t where x < 1 and y = 1 and z > 1;这条语句怎么建索引？
##MySQL的事务是什么？什么是事务一致性？
##MySQL的事务隔离有哪些等级？幻读是什么？和不可重读有什么区别？
##++i，i++，i += 1，三者有什么区别？（我算法题里面有用到这样的写法，所以估计是顺便问的）

#项目相关
##ES相关内容，索引，查询，入库
##爬取内容相关的问题，碰到什么问题，怎么解决？

##跳棋AI设计
##电商促销功能架构设计

#笔试（图片见附件，求能装多少水）
##横平竖直的多边形，求周长K等分点的坐标
##只使用单向链表，做十进制加法
##用一组数来表述连续的柱子的高度，求下雨后，这些柱子能接多少雨水？
如[0,1,0,1,2,1,0,3,1,0]，下雨后，雨水数量为4。黑色为柱子，蓝色为雨水，见附件图

#一面
##Http code 502,504的含义，如何truble shooting
##mysql如何加索引，如何加联合索引
##分布式系统下，如何保证有请求重试的情况下，业务逻辑的正确性，以及解决并发的问题

#二面
##使用面向对象的思路，设计多层，每层有多个电梯的大楼的电梯系统
##http协议具体是由哪些内容组成的
##分布式系统下，如果提供服务限流，如短信服务，每分钟，每个服务调用方只能给每个手机发60条短信

##域名逆序
如：www.baidu.com -> com.baidu.www
##一个链表a1->a2->a3->...a(n-3)->a(n-2)->a(n-1)->an,对折，后部分逆序和前部分合并。输出a1->an->a2->a(n-1)->a3->a(n-2)->...
##矩阵倾斜输出，给定任意矩阵(m x n):
(0,0),(1,0),(2,0),(3,0)
(0,1),(1,1),(2,1),(3,1)
(0,2),(1,2),(2,2),(3,2)
输出顺序：
(0,0)
(1,0),(0,1)
(2,0),(1,1),(0,2)
(3,0),(2,1),(1,2)
(3,1),(2,2)
(3,2)
##天空中最多的飞机数量。航班时刻表中，每个航班都有在起飞时间和降落时间(不跨天)。航班时刻表数量巨大。给定所有航班起飞和降落时刻
(depTime,arrTime)
求在天上飞行的飞机的数量最多是多少
如：
int foo(List{(9:00,14:00),(8:00,11:00),(18:00,23:00)......})
{
    return 最多多少飞机
}
##解释微信浏览器登录，手机扫描二维码实现浏览器登录微信。具体原理
##设计一个长链转短链的系统
##浏览器输入一个网址，点击回车，发生了什么？
##执行抓取任务的时候，任务有时效性，任务异步执行。越新的任务优先级越高。使用redis实现这个任务管理。

##字符串转32位整数，要求能检测无效字符以及整数溢出
int str2int(const char *s){
    /* your code here */
}

##原地反转单链表
例如：1->2->3->4->5->(nil)
变成：5->4->3->2->1->(nil)

struct Node{
    struct Node *next;
    int data;
};

void reverse(struct Node *list){
    /* your code here */
}

##合并有序链表
例如：1->4->5->(nil)
例如：2->3->6->(nil)
变成：1->2->3->4->5->6->(nil)

struct Node{
    struct Node *next;
    int data;
};

struct Node *merge(struct Node *a, struct Node *b){
    /* your code here */
}

##计算某个元素在二叉树中的遍历顺序
例如：
      1
     / \
    2   3
   /\    \
  4  5    6
输入：5
输出：1,2,5

struct Node{
    struct Node *left;
    struct Node *right;
};

void print_path(struct Node *root, int value){
    /* your code here */
}

##求两个等长排序数组的中位数
例如：1,3,5,7,9
以及：2,4,6,8,10
输出：5.5

double get_mid(int *a, int *b, int count){
    /* your code here */
}

##雨水问题
例如：见附件图片
输入：0,1,0,2,1,0,1,3,2,1,2,1
输出：6


##如何判断一个数是否在40亿个整数中？
40亿个整数，一个整数4个字节，存储40亿个整数需要16G内存，如果机器只有2G内存则不可用。
如果允许多台机器，则可以使用分布式的计算方法，将这40亿个数据均分到分布式系统的机器中，当需要查找某个数时直接下发到每台机器上去找，若找到则返回结果。
还有一种更优的方法：使用bitmap算法的思路
可以申请一个40亿的位即可，定义一个int32的整数，大概有2^32个位，也就是42亿多，一个数字代表一个位，若判断一个数是否存在，则只需要判断该位是否为1即可。这个算法就是大数据领域比较有名的bitmap算法。

##如何实现可以获取最小值的栈？
一般方法：使用一个变量来保存栈中的最小值，如果最小值被pop出去了，就没有记录了，不可取。时间复杂度为o(n)，空间复杂度o(1)
高级方法：申请一个辅助栈，辅助栈中就保存最小值。时间复杂度o(1)，空间复杂度o(n)
究极方法：申请一个辅助栈，辅助栈中保存最小值的索引，当push插入元素时，与最小值相同元素的时候就不需要变更辅助栈，而pop出栈的时候，pop出的元素的索引如果和辅助栈中保存的索引不匹配的话，则辅助栈不出栈。这样在保持时间复杂度不变的情况下，减少了空间复杂度。














































##做过的项目及产品详细讲述
项目背景、技术规格、项目难点、解决办法、工作职责

##表达出较强烈的意愿

##薪资
薪资结构及组成，公积金，福利，奖金

##负责对标业内顶级PaaS和SaaS平台的需求研究、技术研究和实现，包括但不限于底层元数据管理、高度灵活的权限管理系统、可扩展的数据存储方案、分布式搜索引擎技术

##负责高质量的设计和编码，承担重点、难点的技术攻坚

##参与产品讨论和开发实现

##计算机相关专业，5年以上后端系统开发经验，有管理经验者优先

##良好的设计和编码品味，热爱写代码，若有代码洁癖更佳
《C++_DSF编码要求和相关技术》
优秀编码四大原则
单一层次 (单一的逻辑层次) 
最小化嵌套
清晰表达式
善于拆分

为了降低DSF的多线和程编程错误,降低DSF对人员的技能要求, 提升SDF的开发效率,本文档给出一系列的原则

线程间同步不要使用信号量:
避免使用信号量，除了维护的代码较多以外，还有一个重要的原因是它容易用错, 避免使用信号量（semaphore），它的功能与条件变量重合，但容易出错
Don’t use a semaphore where a mutex would suffice. 如果 Mutex 就能解决问题的话，不要使用信号量 semaphore
最后不得已必须使用底层同步原语(primitives) 时，只用非递归的互斥器和条件
变量，偶尔用一用读写锁
使用高级的并发编程构件，如TaskQueue、CountDownLatch 等等
锁只能用DSF封装的锁的方法.  只准使用auto_tlock 和 auto_spin_lock.
只准使用原子锁或mutex锁+条件变量
􀁺 只能用RAII 手法封装mutex/splinlock 的创建、销毁、加锁、解锁这四个操作。
􀁺 只用非递归的mutex（即不可重入的mutex）。
􀁺 不用读写锁, 使用以下技术来代替读写锁

10.4	借助智能指针实现多线程下copy-and-write技术 –代替读写锁的一种技术
平台常遇到的一个场景是:多个工作线程来读取一些数据(如缓存服务数据), 一个或多个刷新线程，不定期更新这些数据, 为了做到多线程安全的数据刷新和读取,常见的最简单的同步办法，用读写锁，工作线程加读锁，刷新线程加写锁。

DSF 中由于刷新数据的时间较长，使用读写锁会导致在刷新数据的时间期间工作线程被阻塞，采用较智能指针实现多线程下copy-and-write技术.用此技术来代替读写锁。

DSF 已实现了正常的单例类模板,只需要使用就行了，不要再自行实现。
//使用时，只需要简单地一代码就行了，如下例子 ：
DSFServiceRouter *p_route = Singleton<DSFServiceRouter>::singleton();

11.1	以tr1::function 和tr1:bind 取代虚函数的技术--
function 和bind 已经纳入了std::tr1，它将彻底改变C++ 库的设计方式，以及应用程序的编写方式。
程序库的设计不应该给使用者带来不必要的限制（耦合），而继承是一种比较强的耦合。虚函数限制其使用者必须从某个class 派生，绝大部分C++ 程序库就是这么做,这也是耦合
面向对象三要素是封装、继承和多态。封装是根本, 继承和多态已不在是必须
虚函数用tr1::function 和tr1:bind代替，很多OO 设计模式，也失去了存在的必要。参见线程池的代码
Tr1::function 和 tr1:bind的性能不是很高, DSF统一使用ext_clouser.
《C++_DSF并发编程手册》
进程间通信
线程间同步
基本原则
原则1: 进程间通信只能使用sockect。
不使用共享内存，不使用POSIX 消息队列,不使用信号量。
注:共享内存收消息时使用停-等方式,和DSF sockect编程中的rector方式不一样,两种通信模式揉合到一个程序里，增加复杂度。加入了'停-等'模式后,会让时延大大提高。做不到1ms时延的要求。
线程间同步
基本原则
原则1: 进程间通信只能使用sockect。
不使用共享内存，不使用POSIX 消息队列,不使用信号量。
注:共享内存收消息时使用停-等方式,和DSF sockect编程中的rector方式不一样,两种通信模式揉合到一个程序里，增加复杂度。加入了'停-等'模式后,会让时延大大提高。做不到1ms时延的要求。
1.不使用信号量
2.不准使用读写锁,替代方案参见并发技术1
3.只准使用自旋锁或互斥锁+条件变量
注:避免使用信号量，除了维护的代码较多以外，还有一个重要的原因是它容易用错, 避免使用信号量（semaphore），它的功能与条件变量重合，但容易出错。

技术1：使用多线程下copy-and-write技术来代替读写锁
应用场景：平台常遇到的一个场景是:多个工作线程来读取一些数据(如服务数据，配置数据), 一个或多个刷新线程，不定期更新这些数据。这是典型的读写问题场景。一般使用读写锁来解决多线程安全的数据刷新和读取。
技术挑战：DSF 中由于刷新ZK服务数据刷新的时间较长，使用读写锁会导致在刷新数据的时间期间工作线程被阻塞,这样是不可接受的。
DSF统一技术方案：DSF 所有的这种读写刷新场景下,统一采用如下:
借助shared_ptr实现多线程安全的copy-on-write 技术

技术2：线程安全的对象回调技术
应用场景：如何保证在执行x的成员函数期间，对象x不会在另一个线程被析构，这是C++多线程编程面临的基本问题，也是最容易出现的问题，最难的问题。
如:上层发送消息时，什么知道IO层对象还活着;IO层收到消息时，回调到上层对象，IO层什么知道上层对象还活着。
DSF发并技术2
技术挑战：C++要求程序员自已管理对象的生命周期,这对象生命周期管理是一个难点,尤其是多线程情况下, 尤其困难。
假设一个对象x,一个线程调用x的成员函数时, 怎样保证如下的竞态条件：
1）调用x的成员函数期间,对象x不会被另一个线程析构？
2）在调用x的成员函数之前，如何知道x这个地象还活着？
3) x 对象在析构时，怎样保证其它线程没有执行这个x的成员函数？
DSF统一技术方案：一般来说，业界有几种做法,如对象永不释放（如全局变量）;使用对象池;对象延迟释放;不使用这种方式,都在一个线程中调用等。
DSF 统一采用如下技术：借助tr1 的shared_ptr和weak_prt来完美解决这个线程安全的对象回调技术，代码示意：
classObservable//not100%threadsafe!
{
public:
voidnotifyObserver() //上层的类
{
MutexLocklock(mutex_);
shared_ptrobj(observer_->lock());//尝试提升，这一步是线程安全的
if(obj){
//提升成功，这说明observer对象是没有被销毁的.
obj->update();//这个时候调用obj是安全的, 没有竞态条件，因为obj在栈上，对象不可能在本作用域内销毁
}else{
//对象已经销毁
…
}
}
private:
tr1::weak_prt<void>observer_;//io类
mutableMutexmutex_;
};

技术3：高性能的线程安全的查找表
应用场景：系统中常见根据关键字查找内容的场景，如DSF收到响应消息时，根据消息ID查找消息上下文,如DSF 链路管理根据IP,port查找链路是否存在。
技术挑战：DSF要求线程安全的，性能高，且使用方便。例如标准库中的map可供选择，但是它们是非线程安全的，并且性能不高。
DSF统一技术方案：DSF并发库已提供了一个高效的线程安全的查找表,DSF所有的模块都只能这个查找表，而不要再去实现一个。
实现原理如下:
通过hash函数将各个key分散到具体的bucket中去，每个bucket带有一个锁,每个bucket又是一个高效的hash_map(tr1::unordered_map), 从而实现线程安全的高并发。

技术4：多线程的任务调度
应用场景：这个是最常见的场景,如IO线程收到消息后,让业务线程处理;如业务要写调用链日志时，使用另外的线程来写日志。
DSF统一技术方案：DSF并发库已提供了一个高效ThreadGroup和DSF闭包, DSF所有的模块都只能这个来进行调度。
DSF 的ThreadGroup和DSF闭包将彻底改变C++ 程序设计方式。面向继承的（虚函数/多态)的编程将会转换成面向闭包的编程,23种设计模式绝大部分已不再需要。
实现原理参见:
<TR1新技术将彻底改变C++ 程序设计方式> (待定)
使用多线程调度，非常简单，只需要两行代码: （如IO收到消息后，需要多线程处理消息,处理函数：void ProcessMsg(MessageImpl*message_impl)
ExtClosure<void()>* fun = NewExtClosure(ProcessMsg, message_impl);
dispatcher_->Push(fun);

技术5：多线程安全的单实例的正确实现方法

技术6：同步等待技术
应用场景：现实生活中常见的场景，如参加一个活动，等人到齐了后一起出发，但是不知道谁先到谁后到。即需要等待某个条件达到要求后才能做后面的事情。如DSF初始化需要启动多个模块,每个模块启动时可能会创建不同的线程作不同的处理逻辑(如注册中心模块启动时会建一个线程和ZK 连接),DSF 初始化需要等这些模块都初始化正常时才认为是初始化成功。但是DSF 初始化线程不知道这些模块什么时候才初始化完成。
DSF统一技术方案：为了简化编程，DSF并发库已提供提供一个同步辅助类CountDownLatch，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。
示意代码参见《DSF编码要求和相关技术》

《Go_DSF编码要求和相关技术》

《提高测试质量的--编写测试代码的四大原则》
原则1：一句话抽象原则(一句话测试声明原则)
这个是最最重要的原则，没有之一. 
这个原则说明的是:测试的最顶层用例必须要抽象成一句话来描述，一行代码一个用例,一个用例必须是一行代码。 以下是一个例子,每一行一个用例：
一名话原则的写法：
func Test_ParsePhoneNumber_Basic(t *testing.T) { //正常用例 test_parsePhoneNumber("0086-135-2094-8999", "135209489999", "+86-135-2094-8999") test_parsePhoneNumber("+86-135-2094-8999", "1352094893999", "+86-135-2094-8999") test_parsePhoneNumber("0086-135-2094-8999", "135209438999", "+86-135-2094-8999") test_parsePhoneNumber("086-135-2094-8999", "13520948999", "+86-135-2094-8999") test_parsePhoneNumber("86-135-2094-8999", "13520948999", "+86-135-2094-8999") 
}
原则2：一目了然原则
测试失败了，错误信息要一目了然，信息要能让你容易跟踪并修改bug
以下是一个例子


《优秀编码就是这么容易--DSF_优秀编码要求》
优秀编码原则1--单一抽象层次
单一抽象层次--一个函数/方法中所有的操作处于相同逻辑层次
优秀编码原则2--最小化缩进
过分深层的缩进，或者“嵌套”，已经困扰了计算机界达25年之久，而且至今仍然是产生混乱代码的罪魁祸首之一。
Noam Chomsky和Gerald Weinberg做过一份研究表明，很少有人能够理解超过3层的嵌套（Yourdon 1986a），很多研究人员建议避免使用超过3层的嵌套。
卫语句可以把我们的视线从异常处理中解放出来，集中精力到正常处理的代码中。
总结:简化复杂的if else 语句，基本就是三个手段
1.针对头重脚轻的if else，尽早使用return返回，从而减少嵌套层次
2.合并分支,有些分支持执行的内容相同，可以合并成为一个分支
3.扁平化,这个例子就是扁平化的例子.
优秀编码原则3--清晰表达式
优秀编码原则4--善用辅助类拆分
类太大或封装的内容太多, 就拆分它
结束语:一些编码理念


##动手能力强，喜欢折腾，有解决复杂问题的能力与兴趣

##编程语言不限，若有golang或python经验更佳

##对可扩展性、稳定性、性能、质量有特别的执着，若有高可用性、高性能Web实践经验更佳

##掌握Web后端开发技术：协议、架构、存储、缓存、搜索、安全、消息队列等

##较好的产品意识，关注数据，愿意将产品效果作为工作最重要的驱动因素

##头条发的邮件，关于如何视频的，提前熟悉下流程
