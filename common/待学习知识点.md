##常用字符串操作函数
字符串长度获取：size()、sizeof()、length()、strlen()、strnlen()[size，length主要用于求string的长度，strlen用于求char*的长度。sizeof用于求所占空间的字节数。strnlen多了一个参数，限制扫描长度，主要用于对不可信数据计算长度。strlen的计算方式是从第一个字符开始找，一直找到结束符'\0'为止。]
内存复制：memcpy_s()、memmove_s()、strncpy_s()[当目标区与源区域有重叠时，使用memmove_s，但是memcpy_s比memmove_s更快。strncpy_s是字符串复制，不是内存整体复制，计算方式为从第一个字符开始，一直到'\0'为止，所以当拷贝的字符串中有'\0'时，只能使用memcpy_s和memmove_s]
内存初始化：memset_s()
字符串复制：substr()，参数类型为string
string s = "0123456789";
string sub1 = s.substr(5); //只有一个数字5表示从下标为5开始一直到结尾：sub1 = "56789"
string sub2 = s.substr(5, 3); //从下标为5开始截取长度为3位：sub2 = "567"
字符串连接：strncat_s()、boost::algorithm::join()[接受一个字符串容器作为第一个参数，第二个参数将这些字符串连接起来，返回连接后的字符串]
字符串分割：strtok_s()、strtok_r()、strsep()[strtok_s是Windows下的分割字符串函数，strtok_r和strsep是Linux下分割字符串函数，参数类型是char*类型]，boost::split()、boost::algorithm::split()[参数类型是string类型]
字符串比较：strncmp()
字符串查找：strchr()、find()、rfind()[strchr的参数类型为char*，find的参数类型为string，rfind()与find()很相似，差别在于查找顺序不一样，rfind()是从指定位置起向前查找，直到串首。]
字符串大小写切换：toupper()、tolower()、_strupr_s()、_strlwr_s()、transform+toupper、transform+tolower()[前两个是转换单字符，中间两个是转换char*，最后两个是转换string]。boost::algorithm::to_upper_copy()、boost::algorithm::to_lower_copy()、boost::algorithm::to_upper()、boost::algorithm::to_lower()[前两个不改变入参，返回值为字符串，后两个改变入参，无返回值]
字符串删除：erase();erase(pos,n);删除从pos开始的n个字符，比如erase(0,1)就是删除第一个字符
字符串替换：
stringstream：stringstream类同时可以支持C风格的串流的输入输出操作。

##拷贝构造函数
Test(Test &c_t)是自定义的拷贝构造函数，拷贝构造函数的名称必须与类名称一致。
当用一个已初始化过了的自定义类类型对象去初始化另一个新构造的对象的时候，拷贝构造函数就会被自动调用。
拷贝构造函数又分为深拷贝和浅拷贝。
深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。

##C++继承中，派生类能继承基类中的成员，如何继承，派生类中是否还需要定义？
派生类能继承基类中的成员函数和成员变量，直接使用即可，也可以在派生类中重新定义。

##链表的使用
把链表实现的模板背下来，以及链表倒序实现
已背下来

##锁的运用
常用的锁操作包括互斥锁，自旋锁，原子操作等，不推荐使用读写锁和信号量。在多CPU的环境中，对持有锁较短的程序来说，使用自旋锁代替一般的互斥锁往往能够提高程序的性能。互斥锁属于sleep-waiting类型，而自旋锁属于busy-waiting类型的锁。

##线程变量
指线程内共享的变量。

##TCP/IP
TCP/IP是一个协议族，TCP五层模型包括物理层、数据链路层、网络层、传输层、应用层。IP协议是网络层的，TCP/UDP协议是传输层的，常见的HTTP、FTP协议是应用层的。

##HTTP/HTTPS
HTTP协议即超文本传送协议，它是建立在TCP协议之上的应用层的协议。
HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。
由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即使不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。

##进程和线程
进程
进程是资源分配的最小单位。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程队列等待，等待程序开始运行。
Linux系统函数fork()就是在父进程中创建一个子进程，所以一般来说，我们在一个进程中接收来自客户端的请求，然后fork一个子进程让其来处理，父进程只需负责监控请求的到来，然后创建子进程让其去处理，这样就能做到并发处理。

线程
线程是程序执行时的最小单位。进程中可以有很多个线程，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。

进程和线程的区别
* 进程是资源分配的最小单位，线程是程序执行的最小单位。
* 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
* 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信是比较麻烦的。
* 但是多进程程序更健壮，因为多线程程序只要有一个线程死掉，整个进程也死掉了，而多进程中一个进程死掉并不会对其他进程造成影响，因为进程有自己独立的地址空间。

##闭包
闭包实际上就是一个函数加上一个状态，一般是函数里面引用了局部变量，局部变量的状态是由函数运行时的状态决定的。

>>>>>>>>>>>>>>>>>>>>>>>>>study here

##虚函数和纯虚函数的作用
虚函数主要作用是“运行时多态”，父类中提供虚函数的实现，为子类提供默认的函数实现。子类可以重写父类的虚函数实现子类的特殊化。虚函数是为了允许用基类的指针来调用子类的这个函数。
包含纯虚函数的类，被称为是“抽象类”。抽象类不能使用new出对象，只有实现了这个纯虚函数的子类才能new出对象。
普通函数是静态编译的，没有运行时多态，只会根据指针或引用的“字面值”类对象，调用自己的普通函数。普通函数是父类为子类提供的“强制实现”。因此，在继承关系中，子类不应该重写父类的普通函数。

6.3	相关的去依赖技术—去掉虚函数  //待补充 
以tr1::function 和tr1:bind 取代虚函数的技术

##多态。c++中虚函数，在派生类中重写虚函数，在运行时怎么知道我具体是运行的哪个子类中的
多态分为静态多态和动态多态
静态多态往往通过函数重载和模版（泛型编程）来实现
动态多态是通过继承+虚函数来实现的，只有在程序运行期间(非编译期)才能判断所引用对象的实际类型，根据其实际类型调用相应的方法。
静态多态和动态多态的区别其实只是在什么时候将函数实现和函数调用关联起来，是在编译时期还是运行时期。

##Golang中数组和切片的差异
数组是一种由固定长度和固定对象类型所组成的数据类型。
切片在声明时不需要指定元素个数(长度)。

##什么是虚拟内存
虚拟内存提供了三个重要的能力：(1)它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。(2)它为每个进程提供了一致的地址空间，从而简化了内存管理。(3)它保护了每个进程的地址空间不被其他进程破坏。


##socket
套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。
应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP/IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。
建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket 。
套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。
服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。
客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。
连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户 端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。
SOCKET连接与TCP连接
创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。
Socket连接与HTTP连接
Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。

##websocket
WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。一开始的握手需要借助HTTP请求完成。
目的：即时通讯，替代轮询
网站上的即时通讯是很常见的，比如网页的QQ，聊天系统等。按照以往的技术能力通常是采用轮询、Comet技术解决。

HTTP协议是非持久化的，单向的网络协议，在建立连接后只允许浏览器向服务器发出请求后，服务器才能返回相应的数据。当需要即时通讯时，通过轮询在特定的时间间隔（如1秒），由浏览器向服务器发送Request请求，然后将最新的数据返回给浏览器。这样的方法最明显的缺点就是需要不断的发送请求，而且通常HTTP request的Header是非常长的，为了传输一个很小的数据 需要付出巨大的代价，是很不合算的，占用了很多的宽带。

缺点：会导致过多不必要的请求，浪费流量和服务器资源，每一次请求、应答，都浪费了一定流量在相同的头部信息上

然而WebSocket的出现可以弥补这一缺点。在WebSocket中，只需要服务器和浏览器通过HTTP协议进行一个握手的动作，然后单独建立一条TCP的通信通道进行数据的传送。

WebSocket与HTTP的关系
相同点
1. 都是一样基于TCP的，都是可靠性传输协议。
2. 都是应用层协议。
不同点
1. WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息。HTTP是单向的。
2. WebSocket是需要握手进行建立连接的。
联系
WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的。

WebSocket与Socket的关系
Socket其实并不是一个协议，而是为了方便使用TCP或UDP而抽象出来的一层，是位于应用层和传输控制层之间的一组接口。

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

当两台主机通信时，必须通过Socket连接，Socket则利用TCP/IP协议建立TCP连接。TCP连接则更依靠于底层的IP协议，IP协议的连接则依赖于链路层等更低层次。

WebSocket则是一个典型的应用层协议。

##restful
RESTful是一种架构的规范与约束、原则，符合这种规范的架构就是RESTful架构。

##文件句柄
所谓句柄实际上是一个数据，是一个Long (整长型)的数据。
句柄是WONDOWS用来标识被应用程序所建立或使用的对象的唯一整数，WINDOWS使用各种各样的句柄标识诸如应用程序实例，窗口，控制，位图，GDI对象等等

##mysql底层的innodb

##B树索引实现
B树是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(logn)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。
typedef struct {

    /*文件数*/
    int  file_num;
	
    /*文件名(key)*/
    char* file_name[max_file_num];
	
    /*指向子节点的指针*/
    BTNode* BTptr[max_file_num+1];
	
    /*文件在硬盘中的存储位置*/
    FILE_HARD_ADDR offset[max_file_num];
	
}BTNode;
https://www.cnblogs.com/vincently/p/4526560.html
https://blog.csdn.net/cyongxue/article/details/16971337

##红黑树


##O(1)复杂度入栈出栈设计，全复杂度为1
把栈的模板背下来

##go-micro
应用了go-micro的可插拔理念

##beego
应用了beego的web化框架，开发了一些可视化界面工具。



##vector，list区别，其内部的排序算法用的是哪种排序 
1.vector数据结构
和数组类似，拥有连续内存空间
能高效的进行随机存取(即数据读取操作)，时间复杂度为o(1);
由于内存空间连续，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。
当vector中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。

2.list数据结构
由双向链表实现的，内存空间不连续
只能通过指针访问数据，随机存取效率低，时间复杂度为o(n);
能高效地进行插入和删除操作。

##给出一个链表，能用快排进行排序吗?(不能开辟额外空间)


##用过网络编程吗？
用golang写过网络编程

##TCP连接
TCP连接过程就是TCP的三次握手过程
DSF Client												DSF Server
   |---------------------- SYN=1 seq=a -------------------->|
   |<--------------- SYN=1 ACK=1 ack=a+1 seq=b -------------|
   |---------------------- ACK=1 ack=b+1 ------------------>|
   |                                                        |
   
##TCP断开过程
TCP断开过程就是TCP的四次挥手过程
DSF Client												DSF Server
   |---------------------- FIN=1 seq=a -------------------->|
   |<--------------------- ACK=1 ack=a+1 -------------------|
   |                                                        |
   |<--------------------- FIN=1 seq=b ---------------------|
   |---------------------- ACK=1 ack=b+1 ------------------>|
   |                                                        |
   
##拥塞控制

##内存管理
golang的内存管理基本思路：提前从操作系统申请一块大内存，然后按大小逐级分割成小内存，当需要申请内存时，根据所需大小分配刚好满足的内存，当小内存使用完后，再从大内存中拿出一块进行分割成小内存，当内存释放后，连续的小内存能够拼接成一块大内存的时候就会释放回大内存块，当大内存块释放后长期不使用时，会释放回操作系统。

##map是怎么实现的
map的内部原理是一个红黑树，它是一个有序的数据容器

##hashmap是怎么实现的
hashmap内部有一个hash函数，它是一个无序的数据容器

##key值时复杂度，如果不用hash，用平衡二叉树怎么样？两者有什么优劣？map插入删除时如果多线程的话怎么保证线程安全？如果用的是hash算法，当链表太长是，需要rehash，怎么保证线程安全

##文件系统


##linux
熟悉linux下的开发及调试，熟悉linux下的常用指令。

##手写程序，给出一颗完全二叉树，现在要插入下一个节点，怎么实现，时间复杂度多少？
背诵二叉树实现模板

##有两个字符串，例如S1=abcbcd，S2=abcd，求S2是否包含在S1中，如果有，则输出每种结果对应的下标，例如S1=abcbcd，S2=abcd时，下标的组合：{0125,0145,0345} 

##现有32G的数据，但是只有8G的内存，怎么对这些数进行排序
bitmap

##有一个大文件，里面存着电话号码，现给出一个电话号码，判断该电话号码在不在该文件中

##现有一个大文件，存着电话号码该该电话号码对应的话费记录，选出前10000个消费最高的电话号码（NlogK）

##手写程序，写一段你认为最好的单例模式的代码
背诵并理解老罗的单例模板

##内存泄漏常用定位手段

##多个线程顺序执行，如果有一个线程运行超时了，那么如何保证超时线程不影响其他线程执行？
答：使用Thread.join(超时时长)。

##HashMap是否线程安全，为什么？

##string-stringbuffer-stringbuilder区别
String 字符串常量
StringBuffer 字符串变量（线程安全）
StringBuilder 字符串变量（非线程安全）

##C++同步和异步

##熟悉哪些linux的命令，如何查找出内存占用率高的代码？
首先使用top命令查看内存占用较高的进程，通过进程判断是哪部分代码内存占用过高

##内存泄露和内存溢出

##hashmap的原理
hashmap是由一个数组组成，每个数组元素都是一个链表

##tcp是怎么实现可靠机制的
tcp是一个长链接，是通过三次握手实现可靠机制的

##shell脚本取出log中访问最多的十个地址，常用shell命令
cat file | grep "url" | caculate

##对象在堆中的存储形式

##hashmap和hashtable的区别

##一个数组中有一个元素只出现一次，其他元素都出现两次，如何找到这个元素

##一个数组中有一个元素只出现一次，其他元素都出现三次，如何找到这个元素

##根据项目（我有一个项目涉及到爬虫，就问了一点关于爬虫的问题）。给定一些爬取页面的url关系图，怎么判断现在遍历到的页面已经爬过了？有没有快速一点的方法？ 
每爬取一个资源，会计算它的hash值，并保存在之前定义好的map表中，爬取到一个新的资源，放入hash表之前也会判断其hash值是否已经存在，如果存在则会丢掉，通过这种方法避免重复。

分布式：应用程序分布在不同的计算机上，通过网络来共同完成一项任务，通常为客户端、服务端模式。分布式和集中式相比，有如下特点：分布性、通信性、稳定性、可扩展性。

##多线程安全


##虚函数表（vtbl）和虚表指针（vptr）
上一篇文还留了个问题没解决呢：就是关于那个虚函数指针的问题。其实这样称呼这个指针是不正确的，他确切的应该称为“虚表指针”。不废话了直接进入正题吧。

当类中有虚函数的时候，编译器会为类插入一个我们看不见的数据并建立一个表。这个表就是虚函数表（vtbl），那个我们看不见的数据就是指向虚函数表的指针——虚表指针（vptr）。虚函数表就是为了保存类中的虚函数的地址。我们可以把虚函数表理解成一个数组，数组中的每个元素存放的就是类中虚函数的地址。当调用虚函数的时候，程序不是像普通函数那样直接跳到函数的代码处，而是先取出vptr即得到虚函数表的地址，根据这个来到虚函数表里，从这个表里取出该函数的地址，最后调用该函数。所以只要不同类的vptr不同，他对应的vtbl就不同，不同的vtbl装着对应类的虚函数地址，这样虚函数就可以完成它的任务了。


https://blog.csdn.net/zhangliao613/article/details/79021606


##TCP和UDP的区别
简单来说，TCP是可靠地，UDP是不可靠的。因为TCP是通过三次握手建立的长连接，UDP只负责将数据传输出去，但是不保证数据能被准确接收，UDP的传输效率高于TCP，当程序需要快速传输大量信息时，可以使用UDP。

##TCP报文的格式，字段的意义
TCP报文段分为首部和数据两部分。
首部固定部分各字段的意义如下：
源端口和目的端口：各占2个字节，分别写入源端口号和目的端口号。
序号：占4个字节。序号使用mod运算。TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。故该字段也叫做“报文段序号”。
确认序号：占4个字节，是期望收到对方下一个报文段的第一个数据字节的序号。若确认序号=N,则表明：到序号N-1为止的所有数据都已正确收到。
数据偏移：占4位，表示TCP报文段的首部长度。注意，“数据偏移”的单位是32位字（即以4字节长的字为计算单位）。故TCP首部的最大长度为60字节。
保留：占6位，保留为今后使用，目前置为0；
紧急URG：当URG=1，表明紧急指针字段有效。这时发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。
确认ACK：当ACK=1时，确认字段才有效。当ACK=0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。
推送PSH：接收方TCP收到PSH=1的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付。
复位RST：当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接。
同步SYN：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1。故SYN置为1，就表示这是一个连接请求和连接接收报文。
终止FIN：用来释放连接。当FIN=1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。
窗口：占2个字节。窗口值作为接收方让发送方设置其发送窗口的依据。
检验和：占2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP数据报一样，在计算检验和时，也要在TCP报文段的前面加上12字节的伪首部。伪首部的格式与UDP用户数据报的伪首部一样，但要将伪首部第四个字段中的17 改为6（协议号），把第5字段中的UDP长度改为TCP长度。
紧急指针：占2字节。紧急指针仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数。

##UDP报文格式


##TCP协议如何来保证传输的可靠性
 TCP通过下列方式来提供可靠性：
1、数据被分割成合理的长度。
2、超时重传机制。当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
3、收到请求后会发出确认响应。当TCP接收端收到数据后，它将发送一个确认。这个确认不是立即发送，通常推迟几分之一秒用来对包的完整性进行校验。 
4、数据检验机制。TCP将保持它首部和数据的检验和。目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。
5、数据去重机制。数据包可能会发生重复，TCP的接收端能够丢弃重复的数据。
6、TCP能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。TCP使用的流量控制协议是可变大小的滑动窗口协议。

##TCP使用的流量控制协议是可变大小的滑动窗口协议。什么是滑动窗口协议？
参考iLearner里的视频教程

##CAsyncSocket的运作流程
CAsyncSocket是一个异步非阻塞通信机制，可以随时发包，也可以随时收包，但是不能保障发送和接收的完成，可以调用GetLastError来判断是哪个错误代码，

连接建立的同时，OnSend就被第一次触发了，主动调用send来发送数据也会触发OnSend函数，由于发送数据有可能不能一次完成，它要干的事情就是根据任务和发送进度调用Send继续发，这个跟接收流程逻辑不同，你永远不需要主动调用Recieve，你只应该在OnRecieve中等待。每次OnRecieve被触发，然后被动调用一次Recieve来接受固定长度的数据，连接可能因为各种原因中断，所以你需要判断m_hSocket是否是连接状态进行自动重连。

##CAsyncSocket与CSocket的区别
CSocket是从CAsyncSocket派生而来，它提供了更高层的WinSockAPI接口，CSocket对象提供阻塞模式，如果需要低层控制和高效率就使用CAsyncSock，如果想要方便的话就使用CSocket类。

##socket阻塞与非阻塞，同步与异步

同步和异步关注的是消息通信机制
同步：发起调用后，在没有得到结果之前，该调用就不返回。
异步：与同步相反，发起调用后，会立即返回，不能得到结果，而是由其它通知或回调来通知调用者。

阻塞/非阻塞是程序在等待调用结果（消息，返回值）时的状态.
阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

##HTTP状态码
表示网页服务器HTTP响应状态的3位数字代码。一般状态码的第一个数字代表了响应的五种状态。
比如2XX开头的代表成功，像200代表请求已成功，表示正常状态。202代表服务器已接受请求，但尚未处理。
3XX代表重定向，需要客户端采取进一步操作才能完成请求。
4XX代表请求错误，401请求身份验证，403表示拒绝执行，404表示请求失败。
5开头代表服务器错误。

##cookie和Session的区别
cookie是客户端保持状态的机制，明文的，可以被篡改，大小有限制
session保存在服务器上，加密的，可以对应无限大的数据。

##golang socket编程
https://blog.csdn.net/lengyuezuixue/article/details/79202336

##golang介绍
Go语言和C/C++相比，代码更加简洁，抽象能力强，程序健壮性好，并发编程容易，编译速度快，丰富的标准库，但性能稍差，垃圾回收暂停和不确定性。
Go语言和Java相比，代码更加简洁，资源消耗少，但二进制代码可移植性稍差
Go语言和Python相比，性能高，但动态灵活性稍差

Go语言语言特性
1、语法简洁
2、语言级并发
机制：
* 通过Go关键字创建协程
* 通过chan进行协程间通信
* 协程阻塞时自动切换，初始栈小并自动增长
效果：
* 极大简化了并发编程
* 提供了并发系统可靠性，避免了死锁、线程阻塞等并发编程常见问题
* 协程占用资源较小，能够支持多核环境下大规模并发任务同时存在
3、基于组合的面对对象
使用组合代替继承
4、自动的依赖管理
机制：
* 未被使用的依赖视为错误
* 沿依赖关系自底向上编译，间接依赖不会重复编译
* 不允许循环依赖
效果：
* 编译快，大型程序速度是C++的50倍
* 不需要makefile
* 降低了包之间的耦合
5、自带的测试框架
机制：
* 统一了测试文件、测试函数命名规则
* 可运行一个测试函数、测试文件、基准函数、所有函数等
* 性能测试框架支持输出用于性能调优用的CPU和内存相关数据
效果：
* 方便快捷，无需为单元测试安装单独的软件，简化了测试用例的编写
* 灵活，运行"go test"即可方便地进行任何想要的测试
* 基准测试输出的数据，有利于在早期发现性能问题
6、清晰的命名管理
机制：
* 命名大写开头公有，小写私有
* 使用包路径、包名引用代码
* 以别名解决命名冲突
效果：
* 公有私有一目了然，不用再写public、private
* 包名保持简短和清晰，且不必担心命名冲突
* 从语法上就能识别一个名字是否属于某个包，利于IDE精准联想
7、简明统一的语法
8、明确健壮的语意
9、简单清晰的错误处理
通过在多返回值中返回错误来实现错误处理
机制：
* 通过最后一个返回值返回错误类型
* defer防止资源泄露
效果：
* 错误处理代码清晰而简单，不需要特别的控制结构
* 显示地错误检查会迫使程序员在错误出现的时候对错误进行思考并进行相应的处理
* defer能够减少嵌套代码

##用户访问一个Web站点的过程
一个Web服务器也被称为HTTP服务器，它通过HTTP协议与客户端通信。这个客户端通常指的是Web浏览器(其实手机端
客户端内部也是浏览器实现的)。
Web服务器的工作原理可以简单地归纳为：
客户机通过TCP/IP协议建立到服务器的TCP连接
客户端向服务器发送HTTP协议请求包，请求服务器里的资源文档
服务器向客户机发送HTTP协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端
客户端与服务器断开。由客户端解释HTML文档，在客户端屏幕上渲染图形结果
一个简单的HTTP事务就是这样实现的，看起来很复杂，原理其实是挺简单的。需要注意的是客户端与服务器之间的通信是非持久连接的，也就是当服务器发送了应答后就与客户机断开连接，等待下一次请求。

##函数回调
回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。
#include <stdio.h>

//返回值(*指针名)(参数列表)
typedef int (*callback)(int,int);
//回调函数
int ADD(callback p, int a, int b){
	return (*p)(a,b);//此处回调add函数...
}
//普通函数
int add(int a, int b){
	return a + b;
}
 
int main(void){
	printf("%d\n",add(1,2));
	printf("%d\n",ADD(add,1,2));
	return 0;
}

##HTTP协议的请求方法
HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。

而常见的有如下几种：

GET: 完整请求一个资源 （常用）
HEAD: 仅请求响应首部
POST：提交表单 （常用）
PUT: (webdav) 上传文件（但是浏览器不支持该方法）
DELETE：(webdav) 删除
OPTIONS：返回请求的资源所支持的方法的方法
TRACE: 追求一个资源请求中间所经过的代理（该方法不能由浏览器发出）

##HTTP状态码
状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。

1xx：指示信息–表示请求已接收，继续处理。
2xx：成功–表示请求已被成功接收、理解、接受。
3xx：重定向–要完成请求必须进行更进一步的操作。
4xx：客户端错误–请求有语法错误或请求无法实现。
5xx：服务器端错误–服务器未能实现合法的请求。
常见状态代码、状态描述的说明如下。

200 OK：客户端请求成功。
301: 永久重定向, Location响应首部的值仍为当前URL，因此为隐藏重定向。
302: 临时重定向，显式重定向, Location响应首部的值为新的URL。
304：Not Modified 未修改，比如本地缓存的资源文件和服务器上比较时，发现并没有修改，服务器返回一个304状态码，告诉浏览器，你不用请求该资源，直接使用本地的资源即可。
400 Bad Request：客户端请求有语法错误，不能被服务器所理解。
401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。
403 Forbidden：服务器收到请求，但是拒绝提供服务。
404 Not Found：请求资源不存在，举个例子：输入了错误的URL。
500 Internal Server Error：服务器发生不可预期的错误。
502: Bad Gateway 前面代理服务器联系不到后端的服务器时出现
503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。
504：Gateway Timeout 这个是代理能联系到后端的服务器，但是后端的服务器在规定的时间内没有给代理服务器响应

##



【【【重要】】】
##重绘和回流的区别
##http协议先关的：http和https区别、post请求实体头部的参数，常见的请求类型，除了get和post还有哪些
##Css如何实现垂直水平居中（两种方案）
##webpack配置相关
##react当中setState函数执行机制（主要是什么时候会立即改变，什么时候不会）
##编程题，高阶函数的实现
##BFC概念理解
##es6 promise回调执行时间

#数据结构和算法
##链表、hashmap、b树......
##指定一个场景，考察算法选择和设计
##两个链表做加法
如
链表1：1->3->4
链表2：   2->6
相加后得到：
链表3：1->5->0 （不考虑进位）
链表4：1->6->0 （考虑进位）

#问答题
##linux开机启动流程
##网络服务调用如何保证幂等性
##对比memcache、redis性能、功能和应用场景
##mysql调优方案

#基础题
##TCP协议，动态规划等，重点考察数据结构和算法，分布式理论相关和解决问题的能力
##找出二叉树和无向图任意两个节点间的最大距离（代码实现）
##使用stack实现queue（代码实现）
##Raft协议、Paxos、Zap协议的区别。详细描述raft协议
##HBase的内部数据存储结构
##Redis中zset在项目中怎么使用的，zset的实现方式，如果让你来实现一个zset会怎么实现
##bloom filter实现原理，以及在HBase中的使用
##Kafka在什么情况下会丢失数据，在什么情况下会乱序
##Hadoop中熟悉什么组件，分别介绍一下架构和应用场景
##介绍自己比较擅长什么，举两个例子（技术方面）

#算法题
##有k个已排序数组，元素可能会重复，求所有元素的中位数和时间复杂度
int selectMid(const vector<vector<int>> &nums)

#基础题
##MySQL的底层数据结构是什么？B+数和红黑树的区别？为啥不用红黑树？如果索引是全内存，不写磁盘B+数还有优势吗？
##select id form t where x < 1 and y = 1 and z > 1;这条语句怎么建索引？
##MySQL的事务是什么？什么是事务一致性？
##MySQL的事务隔离有哪些等级？幻读是什么？和不可重读有什么区别？
##++i，i++，i += 1，三者有什么区别？（我算法题里面有用到这样的写法，所以估计是顺便问的）

#项目相关
##ES相关内容，索引，查询，入库
##爬取内容相关的问题，碰到什么问题，怎么解决？

##跳棋AI设计
##电商促销功能架构设计

#笔试（图片见附件，求能装多少水）
##横平竖直的多边形，求周长K等分点的坐标
##只使用单向链表，做十进制加法
##用一组数来表述连续的柱子的高度，求下雨后，这些柱子能接多少雨水？
如[0,1,0,1,2,1,0,3,1,0]，下雨后，雨水数量为4。黑色为柱子，蓝色为雨水，见附件图

#一面
##Http code 502,504的含义，如何truble shooting
##mysql如何加索引，如何加联合索引
##分布式系统下，如何保证有请求重试的情况下，业务逻辑的正确性，以及解决并发的问题

#二面
##使用面向对象的思路，设计多层，每层有多个电梯的大楼的电梯系统
##http协议具体是由哪些内容组成的
##分布式系统下，如果提供服务限流，如短信服务，每分钟，每个服务调用方只能给每个手机发60条短信

##域名逆序
如：www.baidu.com -> com.baidu.www
##一个链表a1->a2->a3->...a(n-3)->a(n-2)->a(n-1)->an,对折，后部分逆序和前部分合并。输出a1->an->a2->a(n-1)->a3->a(n-2)->...
##矩阵倾斜输出，给定任意矩阵(m x n):
(0,0),(1,0),(2,0),(3,0)
(0,1),(1,1),(2,1),(3,1)
(0,2),(1,2),(2,2),(3,2)
输出顺序：
(0,0)
(1,0),(0,1)
(2,0),(1,1),(0,2)
(3,0),(2,1),(1,2)
(3,1),(2,2)
(3,2)
##天空中最多的飞机数量。航班时刻表中，每个航班都有在起飞时间和降落时间(不跨天)。航班时刻表数量巨大。给定所有航班起飞和降落时刻
(depTime,arrTime)
求在天上飞行的飞机的数量最多是多少
如：
int foo(List{(9:00,14:00),(8:00,11:00),(18:00,23:00)......})
{
    return 最多多少飞机
}
##解释微信浏览器登录，手机扫描二维码实现浏览器登录微信。具体原理
##设计一个长链转短链的系统
##浏览器输入一个网址，点击回车，发生了什么？
##执行抓取任务的时候，任务有时效性，任务异步执行。越新的任务优先级越高。使用redis实现这个任务管理。

##字符串转32位整数，要求能检测无效字符以及整数溢出
int str2int(const char *s){
    /* your code here */
}

##原地反转单链表
例如：1->2->3->4->5->(nil)
变成：5->4->3->2->1->(nil)

struct Node{
    struct Node *next;
    int data;
};

void reverse(struct Node *list){
    /* your code here */
}

##合并有序链表
例如：1->4->5->(nil)
例如：2->3->6->(nil)
变成：1->2->3->4->5->6->(nil)

struct Node{
    struct Node *next;
    int data;
};

struct Node *merge(struct Node *a, struct Node *b){
    /* your code here */
}

##计算某个元素在二叉树中的遍历顺序
例如：
      1
     / \
    2   3
   /\    \
  4  5    6
输入：5
输出：1,2,5

struct Node{
    struct Node *left;
    struct Node *right;
};

void print_path(struct Node *root, int value){
    /* your code here */
}

##求两个等长排序数组的中位数
例如：1,3,5,7,9
以及：2,4,6,8,10
输出：5.5

double get_mid(int *a, int *b, int count){
    /* your code here */
}

##雨水问题
例如：见附件图片
输入：0,1,0,2,1,0,1,3,2,1,2,1
输出：6


##如何判断一个数是否在40亿个整数中？
40亿个整数，一个整数4个字节，存储40亿个整数需要16G内存，如果机器只有2G内存则不可用。
如果允许多台机器，则可以使用分布式的计算方法，将这40亿个数据均分到分布式系统的机器中，当需要查找某个数时直接下发到每台机器上去找，若找到则返回结果。
还有一种更优的方法：使用bitmap算法的思路
可以申请一个40亿的位即可，定义一个int32的整数，大概有2^32个位，也就是42亿多，一个数字代表一个位，若判断一个数是否存在，则只需要判断该位是否为1即可。这个算法就是大数据领域比较有名的bitmap算法。

##如何实现可以获取最小值的栈？
一般方法：使用一个变量来保存栈中的最小值，如果最小值被pop出去了，就没有记录了，不可取。时间复杂度为o(n)，空间复杂度o(1)
高级方法：申请一个辅助栈，辅助栈中就保存最小值。时间复杂度o(1)，空间复杂度o(n)
究极方法：申请一个辅助栈，辅助栈中保存最小值的索引，当push插入元素时，与最小值相同元素的时候就不需要变更辅助栈，而pop出栈的时候，pop出的元素的索引如果和辅助栈中保存的索引不匹配的话，则辅助栈不出栈。这样在保持时间复杂度不变的情况下，减少了空间复杂度。














































##做过的项目及产品详细讲述
项目背景、技术规格、项目难点、解决办法、工作职责

##表达出较强烈的意愿

##薪资
薪资结构及组成，公积金，福利，奖金

##负责对标业内顶级PaaS和SaaS平台的需求研究、技术研究和实现，包括但不限于底层元数据管理、高度灵活的权限管理系统、可扩展的数据存储方案、分布式搜索引擎技术

##负责高质量的设计和编码，承担重点、难点的技术攻坚

##参与产品讨论和开发实现

##计算机相关专业，5年以上后端系统开发经验，有管理经验者优先

##良好的设计和编码品味，热爱写代码，若有代码洁癖更佳
《C++_DSF编码要求和相关技术》
优秀编码四大原则
单一层次 (单一的逻辑层次) 
最小化嵌套
清晰表达式
善于拆分

为了降低DSF的多线和程编程错误,降低DSF对人员的技能要求, 提升SDF的开发效率,本文档给出一系列的原则

线程间同步不要使用信号量:
避免使用信号量，除了维护的代码较多以外，还有一个重要的原因是它容易用错, 避免使用信号量（semaphore），它的功能与条件变量重合，但容易出错
Don’t use a semaphore where a mutex would suffice. 如果 Mutex 就能解决问题的话，不要使用信号量 semaphore
最后不得已必须使用底层同步原语(primitives) 时，只用非递归的互斥器和条件
变量，偶尔用一用读写锁
使用高级的并发编程构件，如TaskQueue、CountDownLatch 等等
锁只能用DSF封装的锁的方法.  只准使用auto_tlock 和 auto_spin_lock.
只准使用原子锁或mutex锁+条件变量
􀁺 只能用RAII 手法封装mutex/splinlock 的创建、销毁、加锁、解锁这四个操作。
􀁺 只用非递归的mutex（即不可重入的mutex）。
􀁺 不用读写锁, 使用以下技术来代替读写锁

10.4	借助智能指针实现多线程下copy-and-write技术 –代替读写锁的一种技术
平台常遇到的一个场景是:多个工作线程来读取一些数据(如缓存服务数据), 一个或多个刷新线程，不定期更新这些数据, 为了做到多线程安全的数据刷新和读取,常见的最简单的同步办法，用读写锁，工作线程加读锁，刷新线程加写锁。

DSF 中由于刷新数据的时间较长，使用读写锁会导致在刷新数据的时间期间工作线程被阻塞，采用较智能指针实现多线程下copy-and-write技术.用此技术来代替读写锁。

DSF 已实现了正常的单例类模板,只需要使用就行了，不要再自行实现。
//使用时，只需要简单地一代码就行了，如下例子 ：
DSFServiceRouter *p_route = Singleton<DSFServiceRouter>::singleton();

11.1	以tr1::function 和tr1:bind 取代虚函数的技术--
function 和bind 已经纳入了std::tr1，它将彻底改变C++ 库的设计方式，以及应用程序的编写方式。
程序库的设计不应该给使用者带来不必要的限制（耦合），而继承是一种比较强的耦合。虚函数限制其使用者必须从某个class 派生，绝大部分C++ 程序库就是这么做,这也是耦合
面向对象三要素是封装、继承和多态。封装是根本, 继承和多态已不在是必须
虚函数用tr1::function 和tr1:bind代替，很多OO 设计模式，也失去了存在的必要。参见线程池的代码
Tr1::function 和 tr1:bind的性能不是很高, DSF统一使用ext_clouser.
《C++_DSF并发编程手册》
进程间通信
线程间同步
基本原则
原则1: 进程间通信只能使用sockect。
不使用共享内存，不使用POSIX 消息队列,不使用信号量。
注:共享内存收消息时使用停-等方式,和DSF sockect编程中的rector方式不一样,两种通信模式揉合到一个程序里，增加复杂度。加入了'停-等'模式后,会让时延大大提高。做不到1ms时延的要求。
线程间同步
基本原则
原则1: 进程间通信只能使用sockect。
不使用共享内存，不使用POSIX 消息队列,不使用信号量。
注:共享内存收消息时使用停-等方式,和DSF sockect编程中的rector方式不一样,两种通信模式揉合到一个程序里，增加复杂度。加入了'停-等'模式后,会让时延大大提高。做不到1ms时延的要求。
1.不使用信号量
2.不准使用读写锁,替代方案参见并发技术1
3.只准使用自旋锁或互斥锁+条件变量
注:避免使用信号量，除了维护的代码较多以外，还有一个重要的原因是它容易用错, 避免使用信号量（semaphore），它的功能与条件变量重合，但容易出错。

技术1：使用多线程下copy-and-write技术来代替读写锁
应用场景：平台常遇到的一个场景是:多个工作线程来读取一些数据(如服务数据，配置数据), 一个或多个刷新线程，不定期更新这些数据。这是典型的读写问题场景。一般使用读写锁来解决多线程安全的数据刷新和读取。
技术挑战：DSF 中由于刷新ZK服务数据刷新的时间较长，使用读写锁会导致在刷新数据的时间期间工作线程被阻塞,这样是不可接受的。
DSF统一技术方案：DSF 所有的这种读写刷新场景下,统一采用如下:
借助shared_ptr实现多线程安全的copy-on-write 技术

技术2：线程安全的对象回调技术
应用场景：如何保证在执行x的成员函数期间，对象x不会在另一个线程被析构，这是C++多线程编程面临的基本问题，也是最容易出现的问题，最难的问题。
如:上层发送消息时，什么知道IO层对象还活着;IO层收到消息时，回调到上层对象，IO层什么知道上层对象还活着。
DSF发并技术2
技术挑战：C++要求程序员自已管理对象的生命周期,这对象生命周期管理是一个难点,尤其是多线程情况下, 尤其困难。
假设一个对象x,一个线程调用x的成员函数时, 怎样保证如下的竞态条件：
1）调用x的成员函数期间,对象x不会被另一个线程析构？
2）在调用x的成员函数之前，如何知道x这个地象还活着？
3) x 对象在析构时，怎样保证其它线程没有执行这个x的成员函数？
DSF统一技术方案：一般来说，业界有几种做法,如对象永不释放（如全局变量）;使用对象池;对象延迟释放;不使用这种方式,都在一个线程中调用等。
DSF 统一采用如下技术：借助tr1 的shared_ptr和weak_prt来完美解决这个线程安全的对象回调技术，代码示意：
classObservable//not100%threadsafe!
{
public:
voidnotifyObserver() //上层的类
{
MutexLocklock(mutex_);
shared_ptrobj(observer_->lock());//尝试提升，这一步是线程安全的
if(obj){
//提升成功，这说明observer对象是没有被销毁的.
obj->update();//这个时候调用obj是安全的, 没有竞态条件，因为obj在栈上，对象不可能在本作用域内销毁
}else{
//对象已经销毁
…
}
}
private:
tr1::weak_prt<void>observer_;//io类
mutableMutexmutex_;
};

技术3：高性能的线程安全的查找表
应用场景：系统中常见根据关键字查找内容的场景，如DSF收到响应消息时，根据消息ID查找消息上下文,如DSF 链路管理根据IP,port查找链路是否存在。
技术挑战：DSF要求线程安全的，性能高，且使用方便。例如标准库中的map可供选择，但是它们是非线程安全的，并且性能不高。
DSF统一技术方案：DSF并发库已提供了一个高效的线程安全的查找表,DSF所有的模块都只能这个查找表，而不要再去实现一个。
实现原理如下:
通过hash函数将各个key分散到具体的bucket中去，每个bucket带有一个锁,每个bucket又是一个高效的hash_map(tr1::unordered_map), 从而实现线程安全的高并发。

技术4：多线程的任务调度
应用场景：这个是最常见的场景,如IO线程收到消息后,让业务线程处理;如业务要写调用链日志时，使用另外的线程来写日志。
DSF统一技术方案：DSF并发库已提供了一个高效ThreadGroup和DSF闭包, DSF所有的模块都只能这个来进行调度。
DSF 的ThreadGroup和DSF闭包将彻底改变C++ 程序设计方式。面向继承的（虚函数/多态)的编程将会转换成面向闭包的编程,23种设计模式绝大部分已不再需要。
实现原理参见:
<TR1新技术将彻底改变C++ 程序设计方式> (待定)
使用多线程调度，非常简单，只需要两行代码: （如IO收到消息后，需要多线程处理消息,处理函数：void ProcessMsg(MessageImpl*message_impl)
ExtClosure<void()>* fun = NewExtClosure(ProcessMsg, message_impl);
dispatcher_->Push(fun);

技术5：多线程安全的单实例的正确实现方法

技术6：同步等待技术
应用场景：现实生活中常见的场景，如参加一个活动，等人到齐了后一起出发，但是不知道谁先到谁后到。即需要等待某个条件达到要求后才能做后面的事情。如DSF初始化需要启动多个模块,每个模块启动时可能会创建不同的线程作不同的处理逻辑(如注册中心模块启动时会建一个线程和ZK 连接),DSF 初始化需要等这些模块都初始化正常时才认为是初始化成功。但是DSF 初始化线程不知道这些模块什么时候才初始化完成。
DSF统一技术方案：为了简化编程，DSF并发库已提供提供一个同步辅助类CountDownLatch，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。
示意代码参见《DSF编码要求和相关技术》

《Go_DSF编码要求和相关技术》

《提高测试质量的--编写测试代码的四大原则》
原则1：一句话抽象原则(一句话测试声明原则)
这个是最最重要的原则，没有之一. 
这个原则说明的是:测试的最顶层用例必须要抽象成一句话来描述，一行代码一个用例,一个用例必须是一行代码。 以下是一个例子,每一行一个用例：
一名话原则的写法：
func Test_ParsePhoneNumber_Basic(t *testing.T) { //正常用例 test_parsePhoneNumber("0086-135-2094-8999", "135209489999", "+86-135-2094-8999") test_parsePhoneNumber("+86-135-2094-8999", "1352094893999", "+86-135-2094-8999") test_parsePhoneNumber("0086-135-2094-8999", "135209438999", "+86-135-2094-8999") test_parsePhoneNumber("086-135-2094-8999", "13520948999", "+86-135-2094-8999") test_parsePhoneNumber("86-135-2094-8999", "13520948999", "+86-135-2094-8999") 
}
原则2：一目了然原则
测试失败了，错误信息要一目了然，信息要能让你容易跟踪并修改bug
以下是一个例子


《优秀编码就是这么容易--DSF_优秀编码要求》
优秀编码原则1--单一抽象层次
单一抽象层次--一个函数/方法中所有的操作处于相同逻辑层次
优秀编码原则2--最小化缩进
过分深层的缩进，或者“嵌套”，已经困扰了计算机界达25年之久，而且至今仍然是产生混乱代码的罪魁祸首之一。
Noam Chomsky和Gerald Weinberg做过一份研究表明，很少有人能够理解超过3层的嵌套（Yourdon 1986a），很多研究人员建议避免使用超过3层的嵌套。
卫语句可以把我们的视线从异常处理中解放出来，集中精力到正常处理的代码中。
总结:简化复杂的if else 语句，基本就是三个手段
1.针对头重脚轻的if else，尽早使用return返回，从而减少嵌套层次
2.合并分支,有些分支持执行的内容相同，可以合并成为一个分支
3.扁平化,这个例子就是扁平化的例子.
优秀编码原则3--清晰表达式
优秀编码原则4--善用辅助类拆分
类太大或封装的内容太多, 就拆分它
结束语:一些编码理念


##动手能力强，喜欢折腾，有解决复杂问题的能力与兴趣

##编程语言不限，若有golang或python经验更佳

##对可扩展性、稳定性、性能、质量有特别的执着，若有高可用性、高性能Web实践经验更佳

##掌握Web后端开发技术：协议、架构、存储、缓存、搜索、安全、消息队列等

##较好的产品意识，关注数据，愿意将产品效果作为工作最重要的驱动因素

##头条发的邮件，关于如何视频的，提前熟悉下流程

##菜鸟教程中的面试经验
