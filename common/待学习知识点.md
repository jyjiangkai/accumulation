##常用字符串操作函数
字符串长度获取：size()、sizeof()、length()、strlen()、strnlen()[size，length主要用于求string的长度，strlen用于求char*的长度。sizeof用于求所占空间的字节数。strnlen多了一个参数，限制扫描长度，主要用于对不可信数据计算长度。strlen的计算方式是从第一个字符开始找，一直找到结束符'\0'为止。]
内存复制：memcpy_s()、memmove_s()、strncpy_s()[当目标区与源区域有重叠时，使用memmove_s，但是memcpy_s比memmove_s更快。strncpy_s是字符串复制，不是内存整体复制，计算方式为从第一个字符开始，一直到'\0'为止，所以当拷贝的字符串中有'\0'时，只能使用memcpy_s和memmove_s]
内存初始化：memset_s()
字符串复制：substr()，参数类型为string
string s = "0123456789";
string sub1 = s.substr(5); //只有一个数字5表示从下标为5开始一直到结尾：sub1 = "56789"
string sub2 = s.substr(5, 3); //从下标为5开始截取长度为3位：sub2 = "567"
字符串连接：strncat_s()、boost::algorithm::join()[接受一个字符串容器作为第一个参数，第二个参数将这些字符串连接起来，返回连接后的字符串]
字符串分割：strtok_s()、strtok_r()、strsep()[strtok_s是Windows下的分割字符串函数，strtok_r和strsep是Linux下分割字符串函数，参数类型是char*类型]，boost::split()、boost::algorithm::split()[参数类型是string类型]
字符串比较：strncmp()
字符串查找：strchr()、find()、rfind()[strchr的参数类型为char*，find的参数类型为string，rfind()与find()很相似，差别在于查找顺序不一样，rfind()是从指定位置起向前查找，直到串首。]
字符串大小写切换：toupper()、tolower()、_strupr_s()、_strlwr_s()、transform+toupper、transform+tolower()[前两个是转换单字符，中间两个是转换char*，最后两个是转换string]。boost::algorithm::to_upper_copy()、boost::algorithm::to_lower_copy()、boost::algorithm::to_upper()、boost::algorithm::to_lower()[前两个不改变入参，返回值为字符串，后两个改变入参，无返回值]
字符串删除：erase();erase(pos,n);删除从pos开始的n个字符，比如erase(0,1)就是删除第一个字符
字符串替换：
stringstream：stringstream类同时可以支持C风格的串流的输入输出操作。

##RPC框架
gRPC是Google最近公布的开源软件，基于最新的HTTP2.0协议，并支持常见的众多编程语言。 我们知道HTTP2.0是基于二进制的HTTP协议升级版本，目前各大浏览器都在快马加鞭的加以支持。 这个RPC框架是基于HTTP协议实现的，底层使用到了Netty框架的支持。

RPC框架
第一，要解决通讯的问题，主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。
第二，要解决寻址的问题，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么，这样才能完成调用。比如基于Web服务协议栈的RPC，就要提供一个endpoint 
URI，或者是从UDDI服务上查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。
第三，当A服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如TCP传递到B服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是序列化（Serialize）或编组（marshal），通过寻址和传输将序列化的二进制发送给B服务器。
第四，B服务器收到请求后，需要对参数进行反序列化（序列化的逆操作），恢复为内存中的表达方式，然后找到对应的方法（寻址的一部分）进行本地调用，然后得到返回值。
第五，返回值还要发送回服务器A上的应用，也要经过序列化的方式发送，服务器A接到后，再反序列化，恢复为内存中的表达方式，交给A服务器上的应用

完整的RPC架构里面包含了四个核心的组件，分别是Client ,Server,Client Stub以及Server Stub，这个Stub大家可以理解为存根。分别说说这几个组件：

客户端（Client）:服务的调用方。
服务端（Server）:真正的服务提供者。
客户端存根:存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。
服务端存根:接收客户端发送过来的消息，将消息解包，并调用本地的方法。

##反转一个单链表
示例：
输入：1->2->3->4->5->NULL
输出：5->4->3->2->1->NULL

//链表反转
Node* reverse(Node* head)
{
	Node* p1 = head->next;
	Node* p2 = head->next;
	Node* p3 = NULL;

	head->next = NULL;
	p3 = head;

	while(p1 != NULL)
	{
		p1 = p1->next;
		p2->next = p3;
		p3 = p2;
		p2 = p1;
	}
	return p3;
}

##拷贝构造函数

##C++继承中，派生类能继承基类中的成员，如何继承，派生类中是否还需要定义？
派生类能继承基类中的成员函数和成员变量，直接使用即可，也可以在派生类中重新定义。

##链表的使用(背下来)

##锁的运用

##TCP/IP
TCP/IP是一个协议族，TCP五层模型包括物理层、数据链路层、网络层、传输层、应用层。IP协议是网络层的，TCP/UDP协议是传输层的，常见的HTTP、FTP协议是应用层的。

##HTTP/HTTPS

##进程和线程
进程
进程是资源分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。
Linux系统函数fork()可以在父进程中创建一个子进程，这样的话，在一个进程接到来自客户端新的请求时就可以复制出一个子进程让其来处理，父进程只需负责监控请求的到来，然后创建子进程让其去处理，这样就能做到并发处理。

线程
线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。

进程和线程的区别
* 进程是资源分配的最小单位，线程是程序执行的最小单位。
* 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
* 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
* 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

##闭包

##Golang中数组和切片的差异
##什么是虚拟内存
##自旋锁和互斥锁的差异，互斥锁是睡眠等待
##socket
##websocket
##restful
##进程和线程的差异
##mysql底层的innodb
##b树索引实现
##O(1)复杂度入栈出栈设计，全复杂度为1
##go-micro
##beego
##多态。c++中虚函数，在派生类中重写虚函数，在运行时怎么知道我具体是运行的哪个子类中的

1.C++多态，常用的STL 
2.vector，list区别，其内部的排序算法用的是哪种排序 
给出一个链表，能用快排进行排序吗？（不能开辟额外空间） 
3.用过网络编程吗？（木有） TCP 连接，断开过程，窗口，拥塞控制 
4.内存管理 
5.map是怎么实现的，hash key值时复杂度，如果不用hash，用平衡二叉树怎么样？两者有什么优劣？map插入删除时如果多线程的话怎么保证线程安全？如果用的是hash算法，当链表太长是，需要rehash，怎么保证线程安全。。。 
5.文件系统，linux （不会，orz） 
6.手写程序，给出一颗完全二叉树，现在要插入下一个节点，怎么实现，时间复杂度多少？（我写了一个log2N∗log2Nlog2N∗log2N 的。。） 

1.有两个字符串，例如S1=abcbcd，S2=abcd，求S2是否包含在S1中，如果有，则输出每种结果对应的下标，例如S1=abcbcd，S2=abcd时，下标的组合：{0125,0145,0345} 
2.现有32G的数据，但是只有8G的内存，怎么对这些数进行排序。 
3.有一个大文件，里面存着电话号码，现给出一个电话号码，判断该电话号码在不在该文件中。 
4.现有一个大文件，存着电话号码该该电话号码对应的话费记录，选出前10000个消费最高的电话号码（NlogK）

7.手写程序，写一段你认为最好的单例模式的代码 
8.内存泄漏常用定位手段

（1）多个线程顺序执行，如果有一个线程运行超时了，那么如何保证超时线程不影响其他线程执行？
答：使用Thread.join(超时时长)。

（20）HashMap是否线程安全，为什么？

string-stringbuffer-stringbuilder区别-小米-乐视-百度
String 字符串常量
StringBuffer 字符串变量（线程安全）
StringBuilder 字符串变量（非线程安全）

C++同步和异步

（13）熟悉哪些linux的命令， 如何查找出内存占用率高的代码？

2、内存泄露和内存溢出
4、hashmap的原理
hashmap是由一个数组组成，每个数组元素都是一个链表

4、tcp是怎么实现可靠机制的
tcp是一个长链接，是通过三次握手实现可靠机制的

2、shell脚本 取出log中访问最多的十个地址，常用shell命令

5、对象在堆中的存储形式

6、hashmap和hashtable的区别

9、一个数组中有一个元素只出现一次，其他元素都出现两次，如何找到这个元素
10、一个数组中有一个元素只出现一次，其他元素都出现三次，如何找到这个元素

3.根据项目（我有一个项目涉及到爬虫，就问了一点关于爬虫的问题）。给定一些爬取页面的url关系图，怎么判断现在遍历到的页面已经爬过了？有没有快速一点的方法？ 
每爬取一个资源，会计算它的hash值，并保存在之前定义好的map表中，爬取到一个新的资源，放入hash表之前也会判断其hash值是否已经存在，如果存在则会丢掉，通过这种方法避免重复。

分布式：应用程序分布在不同的计算机上，通过网络来共同完成一项任务，通常为客户端、服务端模式。分布式和集中式相比，有如下特点：分布性、通信性、稳定性、可扩展性。


2、多线程安全


docker 常用命令：
docker ps 查看运行的容器
docker pa -a 查看所有的容器，包括已经停止的容器
docker images 查看所有的镜像
docker start <容器号> 开启容器
docker restart <容器号> 重启容器
docker stop <容器号> 停止正在运行的容器
docker exec -it <容器号> /bin/bash 进入一个正在运行（up状态）的容器
exit 退出已经进入的该容器
docker version 查看docker的版本号等信息
docker info 查看系统层面的信息
docker rm <容器号> 删除一个容器
docker rmi <镜像名> 删除一个镜像
dcoker top <容器名> 查看docker容器内部运行的进程


https://blog.csdn.net/zhangliao613/article/details/79021606
