##常用字符串操作函数
字符串长度获取：size()、sizeof()、length()、strlen()、strnlen()[size，length主要用于求string的长度，strlen用于求char*的长度。sizeof用于求所占空间的字节数。strnlen多了一个参数，限制扫描长度，主要用于对不可信数据计算长度。strlen的计算方式是从第一个字符开始找，一直找到结束符'\0'为止。]
内存复制：memcpy_s()、memmove_s()、strncpy_s()[当目标区与源区域有重叠时，使用memmove_s，但是memcpy_s比memmove_s更快。strncpy_s是字符串复制，不是内存整体复制，计算方式为从第一个字符开始，一直到'\0'为止，所以当拷贝的字符串中有'\0'时，只能使用memcpy_s和memmove_s]
内存初始化：memset_s()
字符串复制：substr()，参数类型为string
string s = "0123456789";
string sub1 = s.substr(5); //只有一个数字5表示从下标为5开始一直到结尾：sub1 = "56789"
string sub2 = s.substr(5, 3); //从下标为5开始截取长度为3位：sub2 = "567"
字符串连接：strncat_s()、boost::algorithm::join()[接受一个字符串容器作为第一个参数，第二个参数将这些字符串连接起来，返回连接后的字符串]
字符串分割：strtok_s()、strtok_r()、strsep()[strtok_s是Windows下的分割字符串函数，strtok_r和strsep是Linux下分割字符串函数，参数类型是char*类型]，boost::split()、boost::algorithm::split()[参数类型是string类型]
字符串比较：strncmp()
字符串查找：strchr()、find()、rfind()[strchr的参数类型为char*，find的参数类型为string，rfind()与find()很相似，差别在于查找顺序不一样，rfind()是从指定位置起向前查找，直到串首。]
字符串大小写切换：toupper()、tolower()、_strupr_s()、_strlwr_s()、transform+toupper、transform+tolower()[前两个是转换单字符，中间两个是转换char*，最后两个是转换string]。boost::algorithm::to_upper_copy()、boost::algorithm::to_lower_copy()、boost::algorithm::to_upper()、boost::algorithm::to_lower()[前两个不改变入参，返回值为字符串，后两个改变入参，无返回值]
字符串删除：erase();erase(pos,n);删除从pos开始的n个字符，比如erase(0,1)就是删除第一个字符
字符串替换：
stringstream：stringstream类同时可以支持C风格的串流的输入输出操作。

##拷贝构造函数
可以自定义类的拷贝构造函数

##C++继承中，派生类能继承基类中的成员，如何继承，派生类中是否还需要定义？
派生类能继承基类中的成员函数和成员变量，直接使用即可，也可以在派生类中重新定义。

##链表的使用
把链表实现的模板背下来，以及链表倒序实现

##锁的运用
常用的锁操作包括互斥锁，自旋锁，原子操作等，不推荐使用读写锁和信号量。在多CPU的环境中，对持有锁较短的程序来说，使用自旋锁代替一般的互斥锁往往能够提高程序的性能。互斥锁属于sleep-waiting类型，而自旋锁属于busy-waiting类型的锁。

##线程变量
指线程内共享的变量。

##TCP/IP
TCP/IP是一个协议族，TCP五层模型包括物理层、数据链路层、网络层、传输层、应用层。IP协议是网络层的，TCP/UDP协议是传输层的，常见的HTTP、FTP协议是应用层的。

##HTTP/HTTPS
HTTP协议即超文本传送协议，它是建立在TCP协议之上的应用层的协议。
HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。
由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即使不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。

##进程和线程
进程
进程是资源分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。
Linux系统函数fork()可以在父进程中创建一个子进程，这样的话，在一个进程接到来自客户端新的请求时就可以复制出一个子进程让其来处理，父进程只需负责监控请求的到来，然后创建子进程让其去处理，这样就能做到并发处理。

线程
线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。

进程和线程的区别
* 进程是资源分配的最小单位，线程是程序执行的最小单位。
* 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
* 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
* 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

##闭包
闭包实际上就是一个函数加上一个状态，一般是函数里面引用了局部变量，局部变量的状态是由函数运行时的状态决定的。

##虚函数和纯虚函数的作用
虚函数主要作用是“运行时多态”，父类中提供虚函数的实现，为子类提供默认的函数实现。子类可以重写父类的虚函数实现子类的特殊化。虚函数是为了允许用基类的指针来调用子类的这个函数。
包含纯虚函数的类，被称为是“抽象类”。抽象类不能使用new出对象，只有实现了这个纯虚函数的子类才能new出对象。
普通函数是静态编译的，没有运行时多态，只会根据指针或引用的“字面值”类对象，调用自己的普通函数。普通函数是父类为子类提供的“强制实现”。因此，在继承关系中，子类不应该重写父类的普通函数。

##Golang中数组和切片的差异
数组是一种由固定长度和固定对象类型所组成的数据类型。
切片在声明时不需要指定元素个数(长度)。

##什么是虚拟内存
虚拟内存提供了三个重要的能力：(1)它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。(2)它为每个进程提供了一致的地址空间，从而简化了内存管理。(3)它保护了每个进程的地址空间不被其他进程破坏。


##socket
套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。
应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP/IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。
建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket 。
套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。
服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。
客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。
连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户 端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。
SOCKET连接与TCP连接
创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。
Socket连接与HTTP连接
Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。

##websocket
WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。一开始的握手需要借助HTTP请求完成。
目的：即时通讯，替代轮询
网站上的即时通讯是很常见的，比如网页的QQ，聊天系统等。按照以往的技术能力通常是采用轮询、Comet技术解决。

HTTP协议是非持久化的，单向的网络协议，在建立连接后只允许浏览器向服务器发出请求后，服务器才能返回相应的数据。当需要即时通讯时，通过轮询在特定的时间间隔（如1秒），由浏览器向服务器发送Request请求，然后将最新的数据返回给浏览器。这样的方法最明显的缺点就是需要不断的发送请求，而且通常HTTP request的Header是非常长的，为了传输一个很小的数据 需要付出巨大的代价，是很不合算的，占用了很多的宽带。

缺点：会导致过多不必要的请求，浪费流量和服务器资源，每一次请求、应答，都浪费了一定流量在相同的头部信息上

然而WebSocket的出现可以弥补这一缺点。在WebSocket中，只需要服务器和浏览器通过HTTP协议进行一个握手的动作，然后单独建立一条TCP的通信通道进行数据的传送。

WebSocket与HTTP的关系
相同点
1. 都是一样基于TCP的，都是可靠性传输协议。
2. 都是应用层协议。
不同点
1. WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息。HTTP是单向的。
2. WebSocket是需要握手进行建立连接的。
联系
WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的。

WebSocket与Socket的关系
Socket其实并不是一个协议，而是为了方便使用TCP或UDP而抽象出来的一层，是位于应用层和传输控制层之间的一组接口。

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

当两台主机通信时，必须通过Socket连接，Socket则利用TCP/IP协议建立TCP连接。TCP连接则更依靠于底层的IP协议，IP协议的连接则依赖于链路层等更低层次。

WebSocket则是一个典型的应用层协议。

##restful
RESTful是一种架构的规范与约束、原则，符合这种规范的架构就是RESTful架构。

##文件句柄
所谓句柄实际上是一个数据，是一个Long (整长型)的数据。
句柄是WONDOWS用来标识被应用程序所建立或使用的对象的唯一整数，WINDOWS使用各种各样的句柄标识诸如应用程序实例，窗口，控制，位图，GDI对象等等

##mysql底层的innodb

##B树索引实现
B树是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(logn)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。
typedef struct {

    /*文件数*/
    int  file_num;
	
    /*文件名(key)*/
    char* file_name[max_file_num];
	
    /*指向子节点的指针*/
    BTNode* BTptr[max_file_num+1];
	
    /*文件在硬盘中的存储位置*/
    FILE_HARD_ADDR offset[max_file_num];
	
}BTNode;
https://www.cnblogs.com/vincently/p/4526560.html
https://blog.csdn.net/cyongxue/article/details/16971337

##红黑树


##O(1)复杂度入栈出栈设计，全复杂度为1
把栈的模板背下来

##go-micro
应用了go-micro的可插拔理念

##beego
应用了beego的web化框架，开发了一些可视化界面工具。

##多态。c++中虚函数，在派生类中重写虚函数，在运行时怎么知道我具体是运行的哪个子类中的
多态分为静态多态和动态多态
静态多态往往通过函数重载和模版（泛型编程）来实现
动态多态是通过继承+虚函数来实现的，只有在程序运行期间(非编译期)才能判断所引用对象的实际类型，根据其实际类型调用相应的方法。
静态多态和动态多态的区别其实只是在什么时候将函数实现和函数调用关联起来，是在编译时期还是运行时期。

##vector，list区别，其内部的排序算法用的是哪种排序 
1.vector数据结构
和数组类似，拥有连续内存空间
能高效的进行随机存取(即数据读取操作)，时间复杂度为o(1);
由于内存空间连续，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。
当vector中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。

2.list数据结构
由双向链表实现的，内存空间不连续
只能通过指针访问数据，随机存取效率低，时间复杂度为o(n);
能高效地进行插入和删除操作。

##给出一个链表，能用快排进行排序吗?(不能开辟额外空间)


##用过网络编程吗？
用golang写过网络编程

##TCP连接
TCP连接过程就是TCP的三次握手过程
DSF Client												DSF Server
   |---------------------- SYN=1 seq=a -------------------->|
   |<--------------- SYN=1 ACK=1 ack=a+1 seq=b -------------|
   |---------------------- ACK=1 ack=b+1 ------------------>|
   |                                                        |
   
##TCP断开过程
TCP断开过程就是TCP的四次挥手过程
DSF Client												DSF Server
   |---------------------- FIN=1 seq=a -------------------->|
   |<--------------------- ACK=1 ack=a+1 -------------------|
   |                                                        |
   |<--------------------- FIN=1 seq=b ---------------------|
   |---------------------- ACK=1 ack=b+1 ------------------>|
   |                                                        |
   
##拥塞控制

##内存管理
golang的内存管理基本思路：提前从操作系统申请一块大内存，然后按大小逐级分割成小内存，当需要申请内存时，根据所需大小分配刚好满足的内存，当小内存使用完后，再从大内存中拿出一块进行分割成小内存，当内存释放后，连续的小内存能够拼接成一块大内存的时候就会释放回大内存块，当大内存块释放后长期不使用时，会释放回操作系统。

##map是怎么实现的
map的内部原理是一个红黑树，它是一个有序的数据容器

##hashmap是怎么实现的
hashmap内部有一个hash函数，它是一个无序的数据容器

##key值时复杂度，如果不用hash，用平衡二叉树怎么样？两者有什么优劣？map插入删除时如果多线程的话怎么保证线程安全？如果用的是hash算法，当链表太长是，需要rehash，怎么保证线程安全

##文件系统


##linux
熟悉linux下的开发及调试，熟悉linux下的常用指令。

##手写程序，给出一颗完全二叉树，现在要插入下一个节点，怎么实现，时间复杂度多少？
背诵二叉树实现模板

##有两个字符串，例如S1=abcbcd，S2=abcd，求S2是否包含在S1中，如果有，则输出每种结果对应的下标，例如S1=abcbcd，S2=abcd时，下标的组合：{0125,0145,0345} 

##现有32G的数据，但是只有8G的内存，怎么对这些数进行排序

##有一个大文件，里面存着电话号码，现给出一个电话号码，判断该电话号码在不在该文件中

##现有一个大文件，存着电话号码该该电话号码对应的话费记录，选出前10000个消费最高的电话号码（NlogK）

##手写程序，写一段你认为最好的单例模式的代码
背诵并理解老罗的单例模板

##内存泄漏常用定位手段

##多个线程顺序执行，如果有一个线程运行超时了，那么如何保证超时线程不影响其他线程执行？
答：使用Thread.join(超时时长)。

##HashMap是否线程安全，为什么？

##string-stringbuffer-stringbuilder区别
String 字符串常量
StringBuffer 字符串变量（线程安全）
StringBuilder 字符串变量（非线程安全）

##C++同步和异步

##熟悉哪些linux的命令，如何查找出内存占用率高的代码？
首先使用top命令查看内存占用较高的进程，通过进程判断是哪部分代码内存占用过高

##内存泄露和内存溢出

##hashmap的原理
hashmap是由一个数组组成，每个数组元素都是一个链表

##tcp是怎么实现可靠机制的
tcp是一个长链接，是通过三次握手实现可靠机制的

##shell脚本取出log中访问最多的十个地址，常用shell命令
cat file | grep "url" | caculate

##对象在堆中的存储形式

##hashmap和hashtable的区别

##一个数组中有一个元素只出现一次，其他元素都出现两次，如何找到这个元素

##一个数组中有一个元素只出现一次，其他元素都出现三次，如何找到这个元素

##根据项目（我有一个项目涉及到爬虫，就问了一点关于爬虫的问题）。给定一些爬取页面的url关系图，怎么判断现在遍历到的页面已经爬过了？有没有快速一点的方法？ 
每爬取一个资源，会计算它的hash值，并保存在之前定义好的map表中，爬取到一个新的资源，放入hash表之前也会判断其hash值是否已经存在，如果存在则会丢掉，通过这种方法避免重复。

分布式：应用程序分布在不同的计算机上，通过网络来共同完成一项任务，通常为客户端、服务端模式。分布式和集中式相比，有如下特点：分布性、通信性、稳定性、可扩展性。

##多线程安全


docker 常用命令：
docker ps 查看运行的容器
docker pa -a 查看所有的容器，包括已经停止的容器
docker images 查看所有的镜像
docker start <容器号> 开启容器
docker restart <容器号> 重启容器
docker stop <容器号> 停止正在运行的容器
docker exec -it <容器号> /bin/bash 进入一个正在运行（up状态）的容器
exit 退出已经进入的该容器
docker version 查看docker的版本号等信息
docker info 查看系统层面的信息
docker rm <容器号> 删除一个容器
docker rmi <镜像名> 删除一个镜像
dcoker top <容器名> 查看docker容器内部运行的进程


https://blog.csdn.net/zhangliao613/article/details/79021606


##TCP和UDP的区别

UDP 与 TCP 的主要区别在于 UDP 不一定提供可靠的数据传输，它不能保证数据准确无误地到达，不过UDP在许多方面非常有效。当程序是要尽快地传输尽可能多的信息时，可以使用 UDP。TCP它是通过三次握手建立的连接，它在两个服务之间始终保持一个连接状态，目的就是为了提供可靠的数据传输。许多程序使用单独的TCP连接和单独的UDP连接，比如重要的状态信息用可靠的TCP连接发送，而主数据流通过UDP发送。

●TCP连接建立的时候3次握手的具体过程，以及其中的每一步是为什么

因为TCP是一个双向通讯协议，所以要三次握手才能建立：

第一次握手是客户端向服务端发送连接请求包（SYN=J），服务端接收到之后会给客户端发个确认标志（也就是两个包，一个是确认包ACK=J+1,另一个是连接询问请求包SYN=K)，这是第二次握手。第三次握手就是客户端会再次给服务端发送消息确认标志ACK=K+1，表示能正常接收可以开始通信。第三次握手的目的是为了防止已经失效的连接请求突然又传送到了服务端，因为网络中有可能存在延迟的问题，如果采用二次握手就会让服务端误认为client是再次发出新的连接请求，然后server一直等待client发来数据，这样就浪费了很多资源。这三次握手是在connect,bind,listen和accept函数中完成的，这几个函数创建了比较可靠的连接通道。其实断开连接的四次握手是跟连接的时候一样的，唯一多了一步就是因为双方都处在连接的时候，而且有可能在传输数据，在服务端接收到客户端的关闭连接请求后它会给客户端确认，但是由于数据还没有传送完毕，此时会进入一个TIME_WAIT状态，所以在数据传送好之后会再次给客户端发消息，这就是多出来的那一步。

●TCP报文的格式，字段的意义

TCP报文段分为首部和数据两部分，首部的前20个字节是固定的，有源端口和目的端口，序号，确认序号，数据偏移，确认ACK,推送复位同步等等。

●TCP协议如何来保证传输的可靠性

第一个是它将数据截断为合理的长度，这一点和UDP完全不同。第二个是超时重发和检验机制，还有对于收到的请求它会给出确认响应。最后它还可以进行流量控制，防止较慢主机的缓冲区溢出。

●TIME_WAIT状态

当有一方接收到另一方的关闭请求并给出确认时，就会进入TIME_WAIT状态。

存在原因：

（1）为了实现TCP全双工连接的可靠释放

（2）为了使一些旧的数据包在网络中因过期而消失

●CAsyncSocket的运作流程

CAsyncSocket是一个异步非阻塞通信机制，可以随时发包，也可以随时收包，但是不能保障发送和接收的完成，可以调用GetLastError来判断是哪个错误代码，

连接建立的同时，OnSend就被第一次触发了，主动调用send来发送数据也会触发OnSend函数，由于发送数据有可能不能一次完成，它要干的事情就是根据任务和发送进度调用Send继续发，这个跟接收流程逻辑不同，你永远不需要主动调用Recieve，你只应该在OnRecieve中等待。每次OnRecieve被触发，然后被动调用一次Recieve来接受固定长度的数据，连接可能因为各种原因中断，所以你需要判断m_hSocket是否是连接状态进行自动重连。

●CAsyncSocket与CSocket的区别

CSocket是从CAsyncSocket派生而来，它提供了更高层的WinSockAPI接口，，CSocket对象提供阻塞模式，如果需要低层控制和高效率就使用CAsyncSock，如果想要方便的话就使用CSocket类。

●socket阻塞与非阻塞，同步与异步

同步/异步主要是针对client端

同步：就是在client端发出一个功能调用时，在没有得到结果之前，该调用就不返回。

异步：与同步相对，当client端调用发出后，会立即返回，但调用者不能立刻得到结果，而是由其它通知或回调来通知调用者。

阻塞/非阻塞主要针对server端

阻塞调用是指调用结果返回之前，当前线程会被挂起，函数只有在得到结果之后才会返回。 非阻塞则会立刻返回。像Recv接口是阻塞的，RecvFrom非阻塞的。

有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。

●HTTP请求

（1）http请求报文：由请求行，请求头，请求数据三部分组成。

请求行包括请求方法、URL和HTTP协议版本。请求方法有GET,POST,HEAD等等。

GET：当客户端要从服务端读取数据时用GET，使用GET方法时，请求参数和对应的值 附加在URL后面，利用一个问号（？）代表URL的结尾和请求参数的开始，传递参数长度受限制，例：/index.jsp?id=100&op=bind

POST:是向服务器提交数据，POST方法请求参数封装在HTTP请求数据中，可以传输大量数据，可用来传送文件。

请求头：由关键字/值对组成，每行一对，关键字和值用冒号隔开，请求头是通知服务端有关于客户端请求的信息。如Host:请求的主机名

请求数据：用于POST方法中。

（2）Get和Post请求的区别：

Get是向服务器索取数据的一种请求，而Post是向服务器提交数据的一种请求。Get请求的参数会跟在url后进行传递,它对传输的数据有大小限制。POST请求的数据会放置在HTML Header内提交。Post比Get安全，当数据是中文或者不敏感的数据，则用get，因为使用get，参数会显示在地址上，对于敏感数据和不是中文字符的数据则用POST。

（3）如何查看GET/POST请求是否发送成功：

借助抓包工具，由返回的结果得出是否请求成功。如HttpAnalyzerstdv7。

（4）HTTP状态码：表示网页服务器HTTP响应状态的3位数字代码。一般状态码的第一个数字代表了响应的五种状态。

比如2XX开头的代表成功，像200代表请求已成功，表示正常状态。202代表服务器已接受请求，但尚未处理。

3XX代表重定向，需要客户端采取进一步操作才能完成请求。

4XX代表请求错误，401请求身份验证，403表示拒绝执行，404表示请求失败。

5开头代表服务器错误。

（5）cookie和Session的区别：cookie是客户端保持状态的机制，明文的，可以被篡改，大小有限制，session保存在服务器上，加密的，可以对应无限大的数据。


##golang socket编程
https://blog.csdn.net/lengyuezuixue/article/details/79202336

##golang介绍
Go语言和C/C++相比，代码更加简洁，抽象能力强，程序健壮性好，并发编程容易，编译速度快，丰富的标准库，但性能稍差，垃圾回收暂停和不确定性。
Go语言和Java相比，代码更加简洁，资源消耗少，但二进制代码可移植性稍差
Go语言和Python相比，性能高，但动态灵活性稍差

Go语言语言特性
1、语法简洁
2、语言级并发
机制：
* 通过Go关键字创建协程
* 通过chan进行协程间通信
* 协程阻塞时自动切换，初始栈小并自动增长
效果：
* 极大简化了并发编程
* 提供了并发系统可靠性，避免了死锁、线程阻塞等并发编程常见问题
* 协程占用资源较小，能够支持多核环境下大规模并发任务同时存在
3、基于组合的面对对象
使用组合代替继承
4、自动的依赖管理
机制：
* 未被使用的依赖视为错误
* 沿依赖关系自底向上编译，间接依赖不会重复编译
* 不允许循环依赖
效果：
* 编译快，大型程序速度是C++的50倍
* 不需要makefile
* 降低了包之间的耦合
5、自带的测试框架
机制：
* 统一了测试文件、测试函数命名规则
* 可运行一个测试函数、测试文件、基准函数、所有函数等
* 性能测试框架支持输出用于性能调优用的CPU和内存相关数据
效果：
* 方便快捷，无需为单元测试安装单独的软件，简化了测试用例的编写
* 灵活，运行"go test"即可方便地进行任何想要的测试
* 基准测试输出的数据，有利于在早期发现性能问题
6、清晰的命名管理
机制：
* 命名大写开头公有，小写私有
* 使用包路径、包名引用代码
* 以别名解决命名冲突
效果：
* 公有私有一目了然，不用再写public、private
* 包名保持简短和清晰，且不必担心命名冲突
* 从语法上就能识别一个名字是否属于某个包，利于IDE精准联想
7、简明统一的语法
8、明确健壮的语意
9、简单清晰的错误处理
通过在多返回值中返回错误来实现错误处理
机制：
* 通过最后一个返回值返回错误类型
* defer防止资源泄露
效果：
* 错误处理代码清晰而简单，不需要特别的控制结构
* 显示地错误检查会迫使程序员在错误出现的时候对错误进行思考并进行相应的处理
* defer能够减少嵌套代码

用户访问一个Web站点的过程
一个Web服务器也被称为HTTP服务器，它通过HTTP协议与客户端通信。这个客户端通常指的是Web浏览器(其实手机端
客户端内部也是浏览器实现的)。
Web服务器的工作原理可以简单地归纳为：
客户机通过TCP/IP协议建立到服务器的TCP连接
客户端向服务器发送HTTP协议请求包，请求服务器里的资源文档
服务器向客户机发送HTTP协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言
的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端
客户机与服务器断开。由客户端解释HTML文档，在客户端屏幕上渲染图形结果
一个简单的HTTP事务就是这样实现的，看起来很复杂，原理其实是挺简单的。需要注意的是客户机与服务器之间的通
信是非持久连接的，也就是当服务器发送了应答后就与客户机断开连接，等待下一次请求。
