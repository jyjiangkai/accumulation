##常用字符串操作函数
字符串长度获取：size()、sizeof()、length()、strlen()、strnlen()[size，length主要用于求string的长度，strlen用于求char*的长度。sizeof用于求所占空间的字节数。strnlen多了一个参数，限制扫描长度，主要用于对不可信数据计算长度。strlen的计算方式是从第一个字符开始找，一直找到结束符'\0'为止。]
内存复制：memcpy_s()、memmove_s()、strncpy_s()[当目标区与源区域有重叠时，使用memmove_s，但是memcpy_s比memmove_s更快。strncpy_s是字符串复制，不是内存整体复制，计算方式为从第一个字符开始，一直到'\0'为止，所以当拷贝的字符串中有'\0'时，只能使用memcpy_s和memmove_s]
内存初始化：memset_s()
字符串复制：substr()，参数类型为string
string s = "0123456789";
string sub1 = s.substr(5); //只有一个数字5表示从下标为5开始一直到结尾：sub1 = "56789"
string sub2 = s.substr(5, 3); //从下标为5开始截取长度为3位：sub2 = "567"
字符串连接：strncat_s()、boost::algorithm::join()[接受一个字符串容器作为第一个参数，第二个参数将这些字符串连接起来，返回连接后的字符串]
字符串分割：strtok_s()、strtok_r()、strsep()[strtok_s是Windows下的分割字符串函数，strtok_r和strsep是Linux下分割字符串函数，参数类型是char*类型]，boost::split()、boost::algorithm::split()[参数类型是string类型]
字符串比较：strncmp()
字符串查找：strchr()、find()、rfind()[strchr的参数类型为char*，find的参数类型为string，rfind()与find()很相似，差别在于查找顺序不一样，rfind()是从指定位置起向前查找，直到串首。]
字符串大小写切换：toupper()、tolower()、_strupr_s()、_strlwr_s()、transform+toupper、transform+tolower()[前两个是转换单字符，中间两个是转换char*，最后两个是转换string]。boost::algorithm::to_upper_copy()、boost::algorithm::to_lower_copy()、boost::algorithm::to_upper()、boost::algorithm::to_lower()[前两个不改变入参，返回值为字符串，后两个改变入参，无返回值]
字符串删除：erase();erase(pos,n);删除从pos开始的n个字符，比如erase(0,1)就是删除第一个字符
字符串替换：
stringstream：stringstream类同时可以支持C风格的串流的输入输出操作。

##


##拷贝构造函数

##C++继承中，派生类能继承基类中的成员，如何继承，派生类中是否还需要定义？
派生类能继承基类中的成员函数和成员变量，直接使用即可，也可以在派生类中重新定义。

##链表的使用(背下来)

##锁的运用

##TCP/IP
TCP/IP是一个协议族，TCP五层模型包括物理层、数据链路层、网络层、传输层、应用层。IP协议是网络层的，TCP/UDP协议是传输层的，常见的HTTP、FTP协议是应用层的。

##HTTP/HTTPS

##进程和线程
进程
进程是资源分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。
Linux系统函数fork()可以在父进程中创建一个子进程，这样的话，在一个进程接到来自客户端新的请求时就可以复制出一个子进程让其来处理，父进程只需负责监控请求的到来，然后创建子进程让其去处理，这样就能做到并发处理。

线程
线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。

进程和线程的区别
* 进程是资源分配的最小单位，线程是程序执行的最小单位。
* 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
* 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
* 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

##闭包

##Golang中数组和切片的差异
##什么是虚拟内存
##自旋锁和互斥锁的差异，互斥锁是睡眠等待
##socket
##websocket
##restful
##进程和线程的差异
##mysql底层的innodb
##b树索引实现
##O(1)复杂度入栈出栈设计，全复杂度为1
##go-micro
##beego
##多态。c++中虚函数，在派生类中重写虚函数，在运行时怎么知道我具体是运行的哪个子类中的

1.C++多态，常用的STL 
2.vector，list区别，其内部的排序算法用的是哪种排序 
给出一个链表，能用快排进行排序吗？（不能开辟额外空间） 
3.用过网络编程吗？（木有） TCP 连接，断开过程，窗口，拥塞控制 
4.内存管理 
5.map是怎么实现的，hash key值时复杂度，如果不用hash，用平衡二叉树怎么样？两者有什么优劣？map插入删除时如果多线程的话怎么保证线程安全？如果用的是hash算法，当链表太长是，需要rehash，怎么保证线程安全。。。 
5.文件系统，linux （不会，orz） 
6.手写程序，给出一颗完全二叉树，现在要插入下一个节点，怎么实现，时间复杂度多少？（我写了一个log2N∗log2Nlog2N∗log2N 的。。） 

1.有两个字符串，例如S1=abcbcd，S2=abcd，求S2是否包含在S1中，如果有，则输出每种结果对应的下标，例如S1=abcbcd，S2=abcd时，下标的组合：{0125,0145,0345} 
2.现有32G的数据，但是只有8G的内存，怎么对这些数进行排序。 
3.有一个大文件，里面存着电话号码，现给出一个电话号码，判断该电话号码在不在该文件中。 
4.现有一个大文件，存着电话号码该该电话号码对应的话费记录，选出前10000个消费最高的电话号码（NlogK）

7.手写程序，写一段你认为最好的单例模式的代码 
8.内存泄漏常用定位手段

（1）多个线程顺序执行，如果有一个线程运行超时了，那么如何保证超时线程不影响其他线程执行？
答：使用Thread.join(超时时长)。

（20）HashMap是否线程安全，为什么？

string-stringbuffer-stringbuilder区别-小米-乐视-百度
String 字符串常量
StringBuffer 字符串变量（线程安全）
StringBuilder 字符串变量（非线程安全）

C++同步和异步

（13）熟悉哪些linux的命令， 如何查找出内存占用率高的代码？

2、内存泄露和内存溢出
4、hashmap的原理
hashmap是由一个数组组成，每个数组元素都是一个链表

4、tcp是怎么实现可靠机制的
tcp是一个长链接，是通过三次握手实现可靠机制的

2、shell脚本 取出log中访问最多的十个地址，常用shell命令

5、对象在堆中的存储形式

6、hashmap和hashtable的区别

9、一个数组中有一个元素只出现一次，其他元素都出现两次，如何找到这个元素
10、一个数组中有一个元素只出现一次，其他元素都出现三次，如何找到这个元素

3.根据项目（我有一个项目涉及到爬虫，就问了一点关于爬虫的问题）。给定一些爬取页面的url关系图，怎么判断现在遍历到的页面已经爬过了？有没有快速一点的方法？ 
每爬取一个资源，会计算它的hash值，并保存在之前定义好的map表中，爬取到一个新的资源，放入hash表之前也会判断其hash值是否已经存在，如果存在则会丢掉，通过这种方法避免重复。

分布式


2、多线程安全