====<<公共知识>>===
##常用字符串操作函数
字符串长度获取：size()、sizeof()、length()、strlen()、strnlen()[size，length主要用于求string的长度，strlen用于求char*的长度。sizeof用于求所占空间的字节数。strnlen多了一个参数，限制扫描长度，主要用于对不可信数据计算长度。strlen的计算方式是从第一个字符开始找，一直找到结束符'\0'为止。]
内存复制：memcpy_s()、memmove_s()、strncpy_s()[当目标区与源区域有重叠时，使用memmove_s，但是memcpy_s比memmove_s更快。strncpy_s是字符串复制，不是内存整体复制，计算方式为从第一个字符开始，一直到'\0'为止，所以当拷贝的字符串中有'\0'时，只能使用memcpy_s和memmove_s]
内存初始化：memset_s()
字符串复制：substr()，参数类型为string
string s = "0123456789";
string sub1 = s.substr(5); //只有一个数字5表示从下标为5开始一直到结尾：sub1 = "56789"
string sub2 = s.substr(5, 3); //从下标为5开始截取长度为3位：sub2 = "567"
字符串连接：strncat_s()、boost::algorithm::join()[接受一个字符串容器作为第一个参数，第二个参数将这些字符串连接起来，返回连接后的字符串]
字符串分割：strtok_s()、strtok_r()、strsep()[strtok_s是Windows下的分割字符串函数，strtok_r和strsep是Linux下分割字符串函数，参数类型是char*类型]，boost::split()、boost::algorithm::split()[参数类型是string类型]
字符串比较：strncmp()
字符串查找：strchr()、find()、rfind()[strchr的参数类型为char*，find的参数类型为string，rfind()与find()很相似，差别在于查找顺序不一样，rfind()是从指定位置起向前查找，直到串首。]
字符串大小写切换：toupper()、tolower()、_strupr_s()、_strlwr_s()、transform+toupper、transform+tolower()[前两个是转换单字符，中间两个是转换char*，最后两个是转换string]。boost::algorithm::to_upper_copy()、boost::algorithm::to_lower_copy()、boost::algorithm::to_upper()、boost::algorithm::to_lower()[前两个不改变入参，返回值为字符串，后两个改变入参，无返回值]
字符串删除：erase();erase(pos,n);删除从pos开始的n个字符，比如erase(0,1)就是删除第一个字符
字符串替换：
stringstream：stringstream类同时可以支持C风格的串流的输入输出操作。

##拷贝构造函数
Test(Test &c_t)是自定义的拷贝构造函数，拷贝构造函数的名称必须与类名称一致。
当用一个已初始化过了的自定义类类型对象去初始化另一个新构造的对象的时候，拷贝构造函数就会被自动调用。
拷贝构造函数又分为深拷贝和浅拷贝。
深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。

##C++继承中，派生类能继承基类中的成员，如何继承，派生类中是否还需要定义？
派生类能继承基类中的成员函数和成员变量，直接使用即可，也可以在派生类中重新定义。

##锁的运用
常用的锁操作包括互斥锁，自旋锁，原子操作等，不推荐使用读写锁和信号量。在多CPU的环境中，对持有锁较短的程序来说，使用自旋锁代替一般的互斥锁往往能够提高程序的性能。互斥锁属于sleep-waiting类型，而自旋锁属于busy-waiting类型的锁。

##线程变量
指线程内共享的变量。

##进程和线程
进程
进程是资源分配的最小单位。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程队列等待，等待程序开始运行。
Linux系统函数fork()就是在父进程中创建一个子进程，所以一般来说，我们在一个进程中接收来自客户端的请求，然后fork一个子进程让其来处理，父进程只需负责监控请求的到来，然后创建子进程让其去处理，这样就能做到并发处理。

线程
线程是程序执行时的最小单位。进程中可以有很多个线程，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。

进程和线程的区别
* 进程是资源分配的最小单位，线程是程序执行的最小单位。
* 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
* 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信是比较麻烦的。
* 但是多进程程序更健壮，因为多线程程序只要有一个线程死掉，整个进程也死掉了，而多进程中一个进程死掉并不会对其他进程造成影响，因为进程有自己独立的地址空间。

##闭包
闭包实际上就是一个函数加上一个状态，一般是函数里面引用了局部变量，局部变量的状态是由函数运行时的状态决定的。

##虚函数和纯虚函数的作用
虚函数主要作用是“多态”，父类中提供虚函数的实现，为子类提供默认的函数实现。子类也可以重写父类的虚函数。

包含纯虚函数的类，被称为是“抽象类”。纯虚函数没有实现，所以抽象类不能使用new出对象，纯虚函数必须要在之类中实现，只有实现了这个纯虚函数的子类才能new出对象。

普通函数是父类为子类提供的“强制实现”。因此，在继承关系中，子类不应该重写父类的普通函数。

相关的去依赖技术----去掉虚函数
以tr1::function 和tr1:bind 取代虚函数的技术

##多态。c++中虚函数，在派生类中重写虚函数，在运行时怎么知道我具体是运行的哪个子类中的
多态分为静态多态和动态多态
静态多态往往通过函数重载和模版（泛型编程）来实现
动态多态是通过继承+虚函数来实现的，只有在程序运行期间(非编译期)才能判断所引用对象的实际类型，根据其实际类型调用相应的方法。
静态多态和动态多态的区别其实只是在什么时候将函数实现和函数调用关联起来，是在编译时期还是运行时期。

##Golang中数组和切片的差异
数组是一种由固定长度和固定对象类型所组成的数据类型。
切片在声明时不需要指定元素个数(长度)。

##什么是虚拟内存
虚拟内存提供了三个重要的能力：
(1)它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。
(2)它为每个进程提供了一致的地址空间，从而简化了内存管理。
(3)它保护了每个进程的地址空间不被其他进程破坏。

##句柄是什么
句柄是用来标识被应用程序所建立或使用的对象的唯一整数，Windows使用各种各样的句柄来标识诸如应用程序实例，窗口，控制，位图，GDI对象等等。
说的确切一点，句柄实际上是一种指向某种资源的指针，但与指针又有所不同：指针对应着一个数据在内存中的地址，得到了指针就可以自由地修改该数据。Windows并不希望一般程序修改其内部数据结构，因为这样太不安全。所以Windows给每个使用GlobalAlloc等函数声明的内存区域指定一个句柄(本质上仍是一个指针，但不要直接操作它)，平时你只是在调用API函数时利用这个句柄来说明要操作哪段内存。当你需要对某个内存进行直接操作时，可以使用GlobalLock锁住这段内存并获得指针来直接进行操作。 

##内存管理
golang的内存管理基本思路：提前从操作系统申请一块大内存，然后按大小逐级分割成小内存，当需要申请内存时，根据所需大小分配刚好满足的内存，当小内存使用完后，再从大内存中拿出一块进行分割成小内存，当内存释放后，连续的小内存能够拼接成一块大内存的时候就会释放回大内存块，当大内存块释放后长期不使用时，会释放回操作系统。

##key值时复杂度，如果不用hash，用平衡二叉树怎么样？两者有什么优劣？
二叉树是一种有序数据结构，查找算法使用的是二分法查找，平均时间复杂度为o(logn)，而hash查找的平均时间复杂度为o(1)，所以hash的性能更高。

##Map插入删除时如果多线程的话怎么保证线程安全？
使用锁来保证map插入删除时多线程安全。

##HashMap线程安全吗？
HashMap不是线程安全的。在并发Rehash的时候，有可能出现环形链表，导致程序进入死循环。

HashMap的Entry数组默认大小为16，目的是为了使Hash算法的结果分布均匀。

HashMap的容量是有限的。当需要的HashMap.size >= Capacity * LoadFactor时，要进行扩容，扩容分两部分：ReSize和ReHash。
* ReSize指的是创建一个新的Entry空数组，长度是原数组的2倍。
* ReHash指的是遍历原Entry数组，把所有的Entry重新Hash到新数组。

Rehash在并发的情况下可能会形成环形链表。可能会导致程序进入死循环。

解决办法可以使用另一个集合类ConcurrentHashMap。这个集合类兼顾了线程安全和性能。
想要避免HashMap的线程安全问题有很多办法，比如改用HashTable或者Collection.synchronizedMap。但是，这两者有着共同的问题：性能。无论读操作还是写操作，它们都会给整个集合加锁，导致同一时间的其他操作为之阻塞。

##Hash冲突有哪些解决方法？
哈希冲突的解决方案有多种:开放定址法，再散列函数法，链地址法，而HashMap即是采用了链地址法

##讲一下Hashmap的扩容过程？
当数据量超过HashMap数组容量的负载因子（默认0.75）之后，就会进行扩容，每次扩容2倍，扩容后会对每个结点重新计算哈希值，这个值可能在两个地方，一个是在原下标的位置，另一个是在下标为<原下标+原容量>的位置。

##HashMap和Hashtable的区别？
Hashtable是线程安全的，效率低，不允许null键null值，Hashtable的hash数组默认大小是11，增加的方式是old*2+1。
HashMap是Hashtable的轻量级实现，是线程不安全的，效率高，允许null键null值，HashMap的hash数组默认大小是16，增加的方式是old*2。

##在Hashtable上下文中，同步指的是什么？
同步意味着在一个时间点只能有一个线程可以修改hash表，任何线程在执行Hashtable的更新操作前都需要获取对象锁，其它线程则等待锁的释放。

##如何实现HashMap的同步？
HashMap可以通过使用Collection.synchronizedMap来达到同步的效果。具体而言，该方法返回一个同步的Map，该Map封装了底层的HashMap的所有方法。

##内存泄露和内存溢出
内存泄漏：分配出去的内存无法回收
内存溢出：程序要求的内存超出了系统所能分配的范围

##对象在堆中的存储形式
1栈：由编译器分配和清除的存储区，存放局部变量和参数。
2堆：通过new分配的内存块，需要程序通过delete去清除，程序运行结束后会由操作系统自动回收。
3全局变量和静态变量存储区：静态变量存储在内存中不需要实例化产生，非静态变量生命周期和该类一致。
4常量存储区：
堆是向高地址位扩展，而栈是向低地址位扩展。

##根据项目（我有一个项目涉及到爬虫，就问了一点关于爬虫的问题）。给定一些爬取页面的url关系图，怎么判断现在遍历到的页面已经爬过了？有没有快速一点的方法？ 
每爬取一个资源，会计算它的hash值，并保存在之前定义好的map表中，爬取到一个新的资源，放入hash表之前也会判断其hash值是否已经存在，如果存在则会丢掉，通过这种方法避免重复。

分布式：应用程序分布在不同的计算机上，通过网络来共同完成一项任务，通常为客户端、服务端模式。分布式和集中式相比，有如下特点：分布性、通信性、稳定性、可扩展性。

##虚函数表（vtbl）和虚表指针（vptr）
上一篇文还留了个问题没解决呢：就是关于那个虚函数指针的问题。其实这样称呼这个指针是不正确的，他确切的应该称为“虚表指针”。不废话了直接进入正题吧。

当类中有虚函数的时候，编译器会为类插入一个我们看不见的数据并建立一个表。这个表就是虚函数表（vtbl），那个我们看不见的数据就是指向虚函数表的指针——虚表指针（vptr）。虚函数表就是为了保存类中的虚函数的地址。我们可以把虚函数表理解成一个数组，数组中的每个元素存放的就是类中虚函数的地址。当调用虚函数的时候，程序不是像普通函数那样直接跳到函数的代码处，而是先取出vptr即得到虚函数表的地址，根据这个来到虚函数表里，从这个表里取出该函数的地址，最后调用该函数。所以只要不同类的vptr不同，他对应的vtbl就不同，不同的vtbl装着对应类的虚函数地址，这样虚函数就可以完成它的任务了。


##阻塞与非阻塞，同步与异步
同步/异步主要针对客户端: 
同步：发起调用后，在没有得到结果之前，该调用就不返回。
异步：与同步相反，发起调用后，会立即返回，不能得到结果，而是由其它通知或回调来通知调用者。

阻塞/非阻塞主要针对服务端:
阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

##多线程安全
常用办法是原子操作和锁。

##函数回调
回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。
#include <stdio.h>

//返回值(*指针名)(参数列表)
typedef int (*callback)(int,int);
//回调函数
int ADD(callback p, int a, int b){
	return (*p)(a,b);//此处回调add函数...
}
//普通函数
int add(int a, int b){
	return a + b;
}
 
int main(void){
	printf("%d\n",add(1,2));
	printf("%d\n",ADD(add,1,2));
	return 0;
}

##重绘和回流的区别
回流：当rendertree中的一部分因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。

重绘：当rendertree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，就称为重绘。

注意：回流必将引起重绘，而重绘不一定会引起回流。

##网络服务调用如何保证幂等性
一次和多次请求某一个资源对于资源本身应该具有同样的副作用（网络超时等问题除外）。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。

可通过全局唯一ID来保证幂等性
如果使用全局唯一ID，就是根据业务的操作和内容生成一个全局ID，在执行操作前先根据这个全局唯一ID是否存在，来判断这个操作是否已经执行。如果不存在则把全局ID，存储到存储系统中，比如数据库、redis等。如果存在则表示该方法已经执行。



====<<数据结构>>===
##链表
把链表实现的模板背下来，以及链表倒序实现
已背下来

##双向链表
双向链表就是链表方向是双方向的，也就是双向链表中的每一个节点有两个指针，一个指针用来指向上一个节点（前驱），另一个指针用指向下一个节点（后继）。
typedef struct DoubleLinkNode
{
   int data;
   struct DoubleLinkNode *prev;
   struct DoubleLinkNode *next;
}
   
##vector原理
概述：动态数组，拥有连续内存空间，能高效的进行随机存取(即数据读取操作)，时间复杂度为o(1)，由于内存空间连续，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。当vector中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。
总结：
需要经常随机访问且不用经常对中间元素删除插入时使用vector
如果元素是结构或类，最好是将结构或类的指针放入vector中，这样不仅能够节省空间，而且可以避免移动时构造和析构操作
删除元素时采用后面的元素覆盖前面的元素的方法可以提高效率

##list原理
概述：双向链表，内存空间不连续，只能通过指针访问数据，随机存取效率低，时间复杂度为o(n)。能高效地进行插入和删除操作。
总结
如果经常进行添加和删除操作并且不经常随机访问的话，使用list
list<指针>完全是性能最低的做法，还不如直接使用list<对象>或使用vector<指针>好，因为指针没有构造与析构，也不占用很大内存

##map
map的内部原理是一个红黑树，它是一个有序的数据容器。

##multimap
多重映照容器
multimap多重映照容器:容器的数据结构采用红黑树进行管理
multimap的所有元素都是pair:第一元素为键值(key),不能修改;第二元素为实值(value),可被修改

multimap特性以及用法与map完全相同，唯一的差别在于:
允许重复键值的元素插入容器(使用了RB-Tree的insert_equal函数) 
因此:
键值key与元素value的映照关系是多对多的关系
没有定义[]操作运算
 
https://blog.csdn.net/chenyujing1234/article/details/8193172

##hashmap
hashmap内部有一个hash函数，它是一个无序的数据容器，首先通过hash函数计算出待查找元素的hash值，然后就能迅速查找到该元素所在位置，若存在hash冲突，则该位置会是一个链表，若没有hash冲突，则该位置只有一个元素，如果是链表，则遍历链表查找元素值。
hashmap是由一个数组组成，每个数组元素都是一个链表，当链表长度大于8时转换为红黑树

##deque
std::deque是双端队列，可以高效的在头尾两端插入和删除元素，在std::deque两端插入和删除并不会使其它元素的指针或引用失效。
双向开口可进可出的容器
概述：按页或块来分配存储器的，每页包含固定数目的元素
如果既需要随机存取，又需要两端数据插入和删除，则应该使用deque

##set原理
Set是关联容器，set中每个元素只包含一个关键字。set支持高效的关键字查询操作——检查一个给定的关键字是否在set中。set也是以红黑树的结构实现，支持高效插入、删除等操作。

##stack
c++stack(堆栈）是一个容器的改编，它实现了一个先进后出的数据结构
使用该容器时需要包含#include<stack>头文件；
定义stack对象的示例代码如下：
stack<int>s1;
stack<string>s2;
stack的基本操作有：
1.入栈：如s.push(x);
2.出栈:如 s.pop().注意：出栈操作只是删除栈顶的元素，并不返回该元素。
3.访问栈顶：如s.top();
4.判断栈空：如s.empty().当栈空时返回true。
5.访问栈中的元素个数，如s.size（）;

##queue
#include<queue>
queue<int> q;

##priority_queue
在<queue>头文件中，还定义了另一个非常有用的模板类priority_queue(优先队列）。优先队列与队列的差别在于优先队列不是按照入队的顺序出队，而是按照队列中元素的优先权顺序出队（默认为大者优先，也可以通过指定算子来指定自己的优先顺序）。

##二叉排序树
二叉树的查找算法实际上就是二分法查找。查找所需的最大次数等同于二叉树的高度。为了解决二叉查找树多次插入后仍能保持平衡，故有了红黑树，红黑树是一种自平衡的二叉查找树。
typedef struct node
{
	int key;
	struct node* lchild;
	struct node* rchild;
}BSTree;

##红黑树
它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。

红黑树的特性:
（1）每个节点或者是黑色，或者是红色。
（2）根节点是黑色。
（3）每个叶子节点（NIL）是黑色。
（4）如果一个节点是红色的，则它的子节点必须是黑色的。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
（5）从一个节点到该节点的子节点的所有路径上包含相同数目的黑节点。

红黑树从根到叶子节点的最长路径不会超过最短路径的2倍。
当插入或者删除操作后，红黑树的规则可能会被打破，这时候就需要做一些调整，主要的调整包括变色和旋转，旋转又分为左旋和右旋。
变色：为了重新符合红黑树的规则，尝试把红色节点变为黑色，或者把黑色节点变为红色。
左旋：逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。
右旋：顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。

红黑树的应用
红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。
例如，Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。

##B树
B树是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(logn)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。

按阶计算（m阶）：ceil()为进一法
[ceil(m/2)-1] <= 关键字 <= m-1
          m/2 <= 子节点 <= m
按度计算（n度）：
          n-1 <= 关键字 <= 2n-1
            n <= 子节点 <= 2n

https://www.cnblogs.com/vincently/p/4526560.html
https://blog.csdn.net/cyongxue/article/details/16971337

B树删除节点关键策略：
场景一：下一步删除R，R在叶子结点中,但是该结点中元素数目为2，删除导致只有1个元素，已经小于最小元素数目ceil(5/2)-1=2,而由前面我们已经知道：如果其某个相邻兄弟结点中比较丰满（元素个数大于ceil(5/2)-1=2），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中（有没有看到红黑树中左旋操作的影子?），在这个实例中，右相邻兄弟结点中比较丰满（3个元素大于2），所以先向父节点借一个元素W下移到该叶子结点中，代替原来S的位置，S前移；然后X在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除X，后面元素前移。
场景二：最后一步删除E，删除后会导致很多问题，因为E所在的结点数目刚好达标，刚好满足最小元素个数（ceil(5/2)-1=2）,而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件，所以需要该节点与某相邻兄弟结点进行合并操作；首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，然后将这两个结点进行合并成一个结点。所以在该实例中，咱们首先将父节点中的元素D下移到已经删除E而只有F的结点中，然后将含有D和F的结点和含有A,C的相邻兄弟结点进行合并成一个结点。
https://www.cnblogs.com/hdk1993/p/5840599.html

##B+树
为所有叶子结点增加一个链指针
所有关键字都在叶子结点出现
B+的特性：
1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
2.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
4.更适合文件索引系统；

按阶计算（m阶）：
[ceil(m/2)-1] <= 关键字 <= m-1
          m/2 <= 子节点 <= m

##B*树
是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；
B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）；
B*树分配新结点的概率比B+树要低，空间使用率更高；

按阶计算（m阶）：
[ceil(m/2)-1] <= 关键字 <= m-1
         2m/3 <= 子节点 <= m
	  
##B树、B+树、B*树的区别
B树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；
B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；
B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；

为什么说B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引？
1) B+-tree的磁盘读写代价更低
B+-tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。
2) B+-tree的查询效率更加稳定
由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

##二叉查找树、自平衡二叉查找树、红黑树、AVL树、B树、B+树、B*树的区别
二叉查找树就是一般的二叉树
自平衡二叉查找树一般指的就是红黑树和AVL树
AVL树是更严格的自平衡二叉查找树，会比红黑树有更多的旋转操作


##栈
栈分为顺序存储栈和链式存储栈
顺序存储栈结构
typedef struct
{
	DataType stack[MAXLEN + 1];
	int top;
}StackType;
顺序存储栈初始化
StackType* initstack()
{
	StackType* s = NULL;
	s = new(StackType);
	if (NULL == s)
	{
		return NULL;
	}
	s->top = 0;
	return s;
}
判断空栈
int empty(StackType* s)
{
	if (s->top == 0)
	{
		return 0;
	}
	return 1;
}
入栈
int push(StackType* s, DataType x)
{
	if (s->top == MAXLEN)
	{
		printf("stack is full.\n");
		return 1;
	}
	
	s->stack[s->top] = x;
	s->top ++;
	
	return 0;
}
出栈
int pop(StackType* s, DataType* px)
{
	if (s->top == 0)
	{
		printf("stack is empty.\n");
		return 1;
	}
	*px = s->stack[s->top --];
	
	return 0;
}

链式存储栈实际上相当于一个链表，但是插入和删除操作只能从链表头部。



====<<算法知识>>===
##常用排序算法
####插入排序
####冒泡排序
####快速排序
####选择排序
####递归排序

常用的排序算法的时间复杂度和空间复杂度
排序方法	最差时间分析	平均时间复杂度	稳定度	空间复杂度
冒泡排序	O(n2)			O(n2)			稳定	O(1)
快速排序	O(n2)			O(n*log2n)		不稳定	O(log2n)~O(n)
选择排序	O(n2)			O(n2)			稳定	O(1)
二叉树排序	O(n2)			O(n*log2n)		不一定	O(n)
插入排序	O(n2)			O(n2)			稳定	O(1)
堆排序		O(n*log2n)		O(n*log2n)		不稳定	O(1)
希尔排序	O				O				不稳定	O(1)

##动态规划
动态规划是一种分阶段求解决策问题的数学思想。它不止用于编程领域，也用于管理学、经济学、生物学。
动态规划中包含三个重要的概念：最优子结构、边界、状态转移公式。

##动态规划题目一
有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。

##动态规划题目二
国王和金矿
有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？
500金/5人，200金/3人，300金/4人，350金/3人，400金/5人

##动态规划----多重背包算法

##动态规划----迪杰特斯拉算法

##备忘录算法
是一种暂存计算结果的方式

##如何判断一个数是否在40亿个整数中？
40亿个整数，一个整数4个字节，存储40亿个整数需要16G内存，如果机器只有2G内存则不可用。
如果允许多台机器，则可以使用分布式的计算方法，将这40亿个数据均分到分布式系统的机器中，当需要查找某个数时直接下发到每台机器上去找，若找到则返回结果。
还有一种更优的方法：使用bitmap算法的思路
可以申请一个40亿的位即可，定义一个int32的整数，大概有2^32个位，也就是42亿多，一个数字代表一个位，若判断一个数是否存在，则只需要判断该位是否为1即可。这个算法就是大数据领域比较有名的bitmap算法。

##如何实现可以获取最小值的栈？
一般方法：使用一个变量来保存栈中的最小值，如果最小值被pop出去了，就没有记录了，不可取。时间复杂度为o(n)，空间复杂度o(1)
高级方法：申请一个辅助栈，辅助栈中就保存最小值。时间复杂度o(1)，空间复杂度o(n)
究极方法：申请一个辅助栈，辅助栈中保存最小值的索引，当push插入元素时，与最小值相同元素的时候就不需要变更辅助栈，而pop出栈的时候，pop出的元素的索引如果和辅助栈中保存的索引不匹配的话，则辅助栈不出栈。这样在保持时间复杂度不变的情况下，减少了空间复杂度。



====<<网络知识>>===
##TCP连接
TCP连接过程就是TCP的三次握手过程
DSF Client												DSF Server
   |---------------------- SYN=1 seq=a -------------------->|
   |<--------------- SYN=1 ACK=1 ack=a+1 seq=b -------------|
   |---------------------- ACK=1 ack=b+1 ------------------>|
   |                                                        |
   
##TCP断开过程
TCP断开过程就是TCP的四次挥手过程
DSF Client												DSF Server
   |---------------------- FIN=1 seq=a -------------------->|
   |<--------------------- ACK=1 ack=a+1 -------------------|
   |                                                        |
   |<--------------------- FIN=1 seq=b ---------------------|
   |---------------------- ACK=1 ack=b+1 ------------------>|
   |                                                        |

##流量控制----滑动窗口
TCP协议可以根据网络中的流量情况，以及发送端和接收端容纳内存的存储情况，来调整对应数据接受量的大小，是通过滑动窗口机制来调整的，窗口的大小是可变的，所以称之为滑动窗口。滑动窗口分为两个，一个是发送端的窗口，一个是接收端的窗口。
滑动窗口的控制过程：假设客户端和服务端要进行数据传递，在客户端上连续发送了四次数据，每次发送的数据大小为1024字节，并且告诉服务端使用的是4096的窗口，所以可以连续发送4个1024的数据，刚好达到发送窗口的大小。服务端接受到数据后，发现自己的服务端窗口大小只有2048，那么客户端发送的4个1024数据最多只能接收两个，另外两个装不下，没有办法进行存储，所以这时候就会导致拥塞，造成数据的丢失，为了避免这种情况的产生，在服务端收到第一个数据后，向客户端回响应的时候，把服务端的窗口大小也发送过去，告诉客户端我的接收窗口大小只有2048，所以客户端收到消息后，发现服务端的接收窗口只有2048，所以就调整客户端的发送窗口为2048，后面再发送的数据就以发送窗口为2048进行发送，一次连续发送两个1024的数据，后面再次发送的时候，会发现服务端返回的窗口大小和自己的窗口大小是一致的，就不需要再调整发送端的窗口了，这个就是我们的滑动窗口机制，通过这个机制我们来控制发送端和接收端的流量大小。

##拥塞控制----慢开始、拥塞避免、快重传、快恢复
慢开始：
1、发送方维持一个叫做“拥塞窗口”的变量，该变量和接收端口共同决定了发送者的发送窗口；
2、当主机开始发送数据时，避免一下子将大量字节注入到网络，造成或者增加拥塞，选择发送一个1字节的试探报文；
3、当收到第一个字节的数据的确认后，就发送2个字节的报文；
4、若再次收到2个字节的确认，则发送4个字节，依次递增2的指数级；
5、最后会达到一个提前预设的“慢开始门限”，比如24，即一次发送了24个分组，此时遵循下面的条件判定：
*1. cwnd < ssthresh， 继续使用慢开始算法；
*2. cwnd > ssthresh，停止使用慢开始算法，改用拥塞避免算法；
*3. cwnd = ssthresh，既可以使用慢开始算法，也可以使用拥塞避免算法；

拥塞避免：
每经过一个往返就把发送方的拥塞窗口+1，即让拥塞窗口缓慢地增大，按照线性规律增长；
当出现网络拥塞，比如丢包时，将慢开始门限设为原先的一半，然后将cwnd设为1，执行慢开始算法；

上述方法的目的是在拥塞发生时循序减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够的时间把队列中积压的分组处理完毕。慢开始和拥塞控制算法常常作为一个整体使用，而快重传和快恢复则是为了减少因为拥塞导致的数据包丢失带来的重传时间，从而避免传递无用的数据到网络。

快重传：
1、接收方建立这样的机制，如果一个包丢失，则对后续的包继续发送针对该包的重传请求；
2、一旦发送方接收到三个一样的确认，就知道该包之后出现了错误，立刻重传该包；
3、此时发送方开始执行“快恢复”算法；

快恢复：
1、慢开始门限减半；
2、cwnd设为慢开始门限减半后的数值；
3、执行拥塞避免算法（高起点，线性增长）；

##TCP和UDP的区别
简单来说，TCP是可靠地，UDP是不可靠的。因为TCP是通过三次握手建立的长连接，UDP只负责将数据传输出去，但是不保证数据能被准确接收，UDP的传输效率高于TCP，当程序需要快速传输大量信息时，可以使用UDP。

##TCP报文的格式，字段的意义
TCP报文段分为首部和数据两部分。
首部固定部分各字段的意义如下：
源端口和目的端口：各占2个字节，分别写入源端口号和目的端口号。
序号：占4个字节。序号使用mod运算。TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。故该字段也叫做“报文段序号”。
确认序号：占4个字节，是期望收到对方下一个报文段的第一个数据字节的序号。若确认序号=N,则表明：到序号N-1为止的所有数据都已正确收到。
数据偏移：占4位，表示TCP报文段的首部长度。注意，“数据偏移”的单位是32位字（即以4字节长的字为计算单位）。故TCP首部的最大长度为60字节。
保留：占6位，保留为今后使用，目前置为0；
紧急URG：当URG=1，表明紧急指针字段有效。这时发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。
确认ACK：当ACK=1时，确认字段才有效。当ACK=0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。
推送PSH：接收方TCP收到PSH=1的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付。
复位RST：当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接。
同步SYN：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1。故SYN置为1，就表示这是一个连接请求和连接接收报文。
终止FIN：用来释放连接。当FIN=1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。
窗口：占2个字节。窗口值作为接收方让发送方设置其发送窗口的依据。
检验和：占2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP数据报一样，在计算检验和时，也要在TCP报文段的前面加上12字节的伪首部。伪首部的格式与UDP用户数据报的伪首部一样，但要将伪首部第四个字段中的17 改为6（协议号），把第5字段中的UDP长度改为TCP长度。
紧急指针：占2字节。紧急指针仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数。

##UDP报文格式
已知

##TCP协议如何来保证传输的可靠性
 TCP通过下列方式来提供可靠性：
1、数据被分割成合理的长度。
2、超时重传机制。当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
3、收到请求后会发出确认响应。当TCP接收端收到数据后，它将发送一个确认。这个确认不是立即发送，通常推迟几分之一秒用来对包的完整性进行校验。 
4、数据检验机制。TCP将保持它首部和数据的检验和。目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。
5、数据去重机制。数据包可能会发生重复，TCP的接收端能够丢弃重复的数据。
6、TCP能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。TCP使用的流量控制协议是可变大小的滑动窗口协议。

##HTTP请求报文格式
HTTP请求报文主要由请求行、请求头部、请求正文3部分组成

请求行：由3部分组成，分别为：请求方法、URL（见备注1）以及协议版本，之间由空格分隔
HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。

请求头部：由“名/值”对组成，每行一对，名和值之间使用冒号分隔
请求头				说明
Host				接受请求的服务器地址，可以是IP:端口号，也可以是域名
User-Agent			发送请求的应用程序名称
Connection			指定与连接相关的属性，如Connection:Keep-Alive
Accept-Charset		通知服务端可以发送的编码格式
Accept-Encoding		通知服务端可以发送的数据压缩格式
Accept-Language		通知服务端可以发送的语言
请求头部的最后会有一个空行，表示请求头部结束，接下来为请求正文，这一行非常重要，必不可少

请求正文：可选部分，比如GET请求就没有请求正文

##HTTP响应报文格式
HTTP响应报文主要由状态行、响应头部、响应正文3部分组成

状态行：由3部分组成，分别为：协议版本，状态码，状态码描述，之间由空格分隔

响应头部：与请求头部类似，为响应报文添加了一些附加信息
响应头				说明
Server				服务器应用程序软件的名称和版本
Content-Type		响应正文的类型（是图片还是二进制字符串）
Content-Length		响应正文长度
Content-Charset		响应正文使用的编码
Content-Encoding	响应正文使用的数据压缩格式
Content-Language	响应正文使用的语言

##HTTP状态码
状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。

1xx：指示信息–表示请求已接收，继续处理。
2xx：成功–表示请求已被成功接收、理解、接受。
3xx：重定向–要完成请求必须进行更进一步的操作。
4xx：客户端错误–请求有语法错误或请求无法实现。
5xx：服务端错误–服务器未能实现合法的请求。
常见状态代码、状态描述的说明如下。

200 OK：客户端请求成功。
301: 永久重定向, Location响应首部的值仍为当前URL，因此为隐藏重定向。
302: 临时重定向，显式重定向, Location响应首部的值为新的URL。
304：Not Modified 未修改，比如本地缓存的资源文件和服务器上比较时，发现并没有修改，服务器返回一个304状态码，告诉浏览器，你不用请求该资源，直接使用本地的资源即可。
400 Bad Request：客户端请求有语法错误，不能被服务器所理解。
401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。
403 Forbidden：服务器收到请求，但是拒绝提供服务。
404 Not Found：请求资源不存在，举个例子：输入了错误的URL。
500 Internal Server Error：服务器发生不可预期的错误。
502: Bad Gateway：前面代理服务器联系不到后端的服务器时出现
503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。
504：Gateway Timeout：这个是代理能联系到后端的服务器，但是后端的服务器在规定的时间内没有给代理服务器响应

##HTTP1.0，HTTP1.1，HTTP2.0，HTTPS
HTTP1.0：支持keep-alive连接，必须发送一个connection:Keep-Alive请求首部来激活keep-alive连接，是通过轮询机制实现的长链接

HTTP1.1：默认支持长链接，增加流水线操作，允许在第一个应答被完全发送之前发送第二个请求，以降低通信的延迟。性能和安全性有所提升。

HTTP2.0：
多路复用，并行的请求能在同一个链接中处理，移除了HTTP/1.x中顺序和阻塞的约束。
多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。
二进制分帧
首部压缩，因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。

HTTPS：
HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。现在的HTTPS都是用的TLS协议，但是由于SSL出现的时间比较早，并且依旧被现在浏览器所支持，因此SSL依然是HTTPS的代名词。
HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，TLS/SSL中使用了非对称加密，对称加密以及HASH算法。

##cookie和session的区别
cookie是客户端保持状态的机制，明文的，可以被篡改，大小有限制
session保存在服务器上，加密的，可以对应无限大的数据。

##用户访问一个Web站点的过程
一个Web服务器也被称为HTTP服务器，它通过HTTP协议与客户端通信。这个客户端通常指的是Web浏览器(其实手机端
客户端内部也是浏览器实现的)。
Web服务器的工作原理可以简单地归纳为：
客户机通过TCP/IP协议建立到服务器的TCP连接
客户端向服务器发送HTTP协议请求包，请求服务器里的资源文档
服务器向客户机发送HTTP协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端
客户端与服务器断开。由客户端解释HTML文档，在客户端屏幕上渲染图形结果
一个简单的HTTP事务就是这样实现的，看起来很复杂，原理其实是挺简单的。需要注意的是客户端与服务器之间的通信是非持久连接的，也就是当服务器发送了应答后就与客户机断开连接，等待下一次请求。



====<<协议知识>>===
##TCP/IP
TCP/IP是一个协议族，TCP五层模型包括物理层、数据链路层、网络层、传输层、应用层。IP协议是网络层的，TCP/UDP协议是传输层的，常见的HTTP、FTP协议是应用层的。

##HTTP/HTTPS
HTTP协议即超文本传送协议，它是建立在TCP协议之上的应用层的协议。
HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。
由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即使不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。

##Socket
Socket也叫套接字，是基于TCP/IP协议封装的接口，目的是为了便于我们更方便的使用TCP/IP协议。

套接字包含网络通信必须的五种信息：使用的协议类型；源端IP地址；目的端IP地址；源端端口号；目的端端口号。

套接字的背景是应用层通过传输层进行数据通信时，可能会有多个TCP连接需要通过同一个TCP协议端口传输数据。所以提供了套接字(Socket)接口，使应用层可以和传输层之间可以通过套接字(Socket)接口区分来自不同网络连接的通信，实现数据传输的并发服务。

建立Socket连接至少需要一对套接字，分别是客户端套接字和服务端套接字。

套接字之间的连接过程分为三个步骤：服务端监听，客户端请求，连接确认。
服务端监听：服务端套接字起一个网络监听，等待客户端的连接请求。
客户端请求：客户端套接字向指定服务端IP地址和端口号的服务端套接字发出连接请求。
连接确认：服务端套接字收到客户端套接字的连接请求时，起一个新的线程，把服务器端套接字的描述信息发给客户 端，一旦客户端确认了此描述信息，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。

##Socket连接与TCP连接的区别
创建Socket连接时，需要指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。

##Socket连接与HTTP连接的区别
Socket连接，服务端可以直接将数据发送给客户端；
HTTP连接，服务端不能主动将数据发送给客户端，需要等到客户端发送一次请求后才能将数据传回给客户端，所以这种情况下，一般客户端会定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。

##Websocket
WebSocket是HTML5的一种新协议。它实现了浏览器与服务器全双工通信。一开始的握手需要借助HTTP请求完成。
Websocket的作用是实现了即时通讯，替代HTTP协议的轮询机制。

##Websocket和HTTP的区别
HTTP协议是非持久化的，单向的网络协议，在建立连接后只允许浏览器向服务端发出请求后，服务端才能返回相应的数据。所以一般是通过轮询的方式来实现即时通讯的，浏览器定时向服务端发送Request请求，然后服务端将最新的数据返回给浏览器。这种方法的缺点主要是需要不断的发送请求，浪费流量和服务器资源，每一次请求和响应，都浪费了一定流量在相同的头部信息上。

WebSocket在建立底层TCP连接后，只需要服务器和浏览器通过HTTP协议进行一个握手的动作，然后就能单独建立一条TCP的通信通道进行数据的传送。

##WebSocket与HTTP的关系
相同点
1. 都是一样基于TCP协议的，都是可靠性传输协议。
2. 都是应用层协议。
不同点
1. WebSocket是全双工通信协议，可以双向发送或接受信息。HTTP是单向的。
2. WebSocket是需要握手进行建立连接的。
联系
WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的。

##WebSocket与Socket的关系
Socket其实并不是一个协议，而是为了方便使用TCP或UDP而抽象出来的一层，是位于应用层和传输控制层之间的一组接口。

##RESTful
RESTful是一种互联网软件架构的约束条件和原则，符合这种规范的架构就是RESTful架构。




====<<面试题目>>===
##O(1)复杂度入栈出栈设计，全复杂度为1
使用链式存储栈即可

##go-micro
应用了go-micro的可插拔理念

##beego
应用了beego的web化框架，开发了一些可视化界面工具。

##给出一个链表，能用快排进行排序吗?(不能开辟额外空间)

##用过网络编程吗？
用golang写过网络编程

##手写程序，给出一颗完全二叉树，现在要插入下一个节点，怎么实现，时间复杂度多少？
typedef struct node
{
	int key;
	struct node* lchild;
	struct node* rchild;
}BSTree;

##有两个字符串，例如S1=abcbcd，S2=abcd，求S2是否包含在S1中，如果有，则输出每种结果对应的下标，例如S1=abcbcd，S2=abcd时，下标的组合：{0125,0145,0345} 

##现有32G的数据，但是只有8G的内存，怎么对这些数进行排序
1TB数据使用32GB内存如何排序 
1、把磁盘上的1TB数据分割为40块（chunks），每份25GB。（注意，要留一些系统空间！） 
2、顺序将每份25GB数据读入内存，使用quick sort算法排序。 
3、把排序好的数据（也是25GB）存放回磁盘。 
4、循环40次，现在，所有的40个块都已经各自排序了。（剩下的工作就是如何把它们合并排序！） 
5、从40个块中分别读取25G/40=0.625G入内存（40 input buffers）。 
6、执行40路合并，并将合并结果临时存储于2GB基于内存的输出缓冲区中。当缓冲区写满2GB时，写入硬盘上最终文件，并清空输出缓冲区；当40个输入缓冲区中任何一个处理完毕时，写入该缓冲区所对应的块中的下一个0.625GB，直到全部处理完成。

##有一个大文件，里面存着电话号码，现给出一个电话号码，判断该电话号码在不在该文件中

##现有一个大文件，存着电话号码该该电话号码对应的话费记录，选出前10000个消费最高的电话号码（NlogK）
step1：根据内存大小，对大文件进行分块，然后逐个将大文件读入内存。
step2：创建hash_map,遍历读入内存中的文件。对于每条记录，先在hash_map中搜索，若有，将hash_map中记录count+1，若没有，插入hash_map
step3:在这个hash_map中，找出count最大的数据

##内存泄漏常用定位手段
一个非常强大的工具valgrind
Valgrind的使用请见手册http://valgrind.org/docs/manual/manual.html

##多个线程顺序执行，如果有一个线程运行超时了，那么如何保证超时线程不影响其他线程执行？
使用Thread.join(超时时长)。

##string-stringbuffer-stringbuilder区别
String 字符串常量
StringBuffer 字符串变量（线程安全）
StringBuilder 字符串变量（非线程安全）

##熟悉哪些linux的命令，如何查找出内存占用率高的代码？
首先使用top命令查看内存占用较高的进程，通过进程判断是哪部分代码内存占用过高
或者ps -aux | sort -k4nr | head -N1

##shell脚本取出log中访问最多的十个地址，常用shell命令
cat file | grep "url" | caculate

##一个数组中有一个元素只出现一次，其他元素都出现两次，如何找到这个元素
int singleNumber(int nums[]) 
{
  int res = nums[0];
  for (int i = 1; i < nums.length; i++)
    res = res^nums[i];

  return res;
}

##一个数组中有一个元素只出现一次，其他元素都出现三次，如何找到这个元素
int singleNumber(int nums[]) {
    int result = 0;
    for (int i = 0; i < 32; i++) {
        int sum = 0;
        for (int j = 0; j < 13; j++) {
            sum += (nums[j] >> i) & 1;
        }
        result |= (sum % 3) << i;
    }
    return result;
}
   
##数组中所有元素出现两次，其中有两个元素只出现一次，找出这两个元素
public static int[] geTwoEle(int[] res){
        if(res.length==2)return res;
        int []val=new int[2];
        int temp=res[0];
        for(int i=1;i<res.length;i++){
            temp^=res[i];
        }
        //find the leftmost pos where two element is different
        int i=0;
        while(temp!=0)temp>>=++i;
        i--;

        int left[]=new int[res.length];
        int right[]=new int[res.length];
        int lefti=0;
        int righti=0;
        //split val array into two arrays according to the different pos
        for(int j=0;j<res.length;j++){
            if(((res[j]>>i)&1)==0){
                left[lefti++]=res[j];
            }else{
                right[righti++]=res[j];
            }
        }
        //in left and right array only one element is different,use ^ to find the element
        val[0]=left[0];
        for(int j=1;j<lefti;j++){
            val[0]^=left[j];
        }

        val[1]=right[0];
        for(int j=1;j<righti;j++){
            val[0]^=right[j];
        }

        return val;
}

https://blog.csdn.net/guoyuguang0/article/details/51034572

##编程题，高阶函数的实现
高阶函数就是把函数作为参数或者返回值的一类函数

##指定一个场景，考察算法选择和设计
如何实现可以获取最小值的栈？
一般方法：使用一个变量来保存栈中的最小值，如果最小值被pop出去了，就没有记录了，不可取。时间复杂度为o(n)，空间复杂度o(1)
高级方法：申请一个辅助栈，辅助栈中就保存最小值。时间复杂度o(1)，空间复杂度o(n)
究极方法：申请一个辅助栈，辅助栈中保存最小值的索引，当push插入元素时，与最小值相同元素的时候就不需要变更辅助栈，而pop出栈的时候，pop出的元素的索引如果和辅助栈中保存的索引不匹配的话，则辅助栈不出栈。这样在保持时间复杂度不变的情况下，减少了空间复杂度。

##两个链表做加法
如
链表1：1->3->4
链表2：   2->6
相加后得到：
链表3：1->5->0 （不考虑进位）
链表4：1->6->0 （考虑进位）


##找出二叉树和无向图任意两个节点间的最大距离（代码实现）
https://blog.csdn.net/beitiandijun/article/details/41978369
基本思想：定义两个vector分别保存二叉树中的节点(vec1和vec2)。从根节点开始向两个待查找节点进行遍历，把第一个节点经过的节点保存在vec1中，把第二个节点经过的节点保存在vec2中，然后遍历对比vec1和vec2，计算出两个vec中的公共节点数，然后用两个vec中的总节点数减去两倍公共节点数即为代查找的两个节点间的最大距离。

##使用两个stack实现queue（代码实现）
思路：
s1作为存储空间，以s2作为临时缓冲区。
入队时，将元素压入s1。
出队时，将s1的元素逐个“倒入”（弹出并压入）s2，将s2的顶元素弹出作为出队元素，之后再将s2剩下的元素逐个“倒回”s1。

##介绍自己比较擅长什么，举两个例子（技术方面）
分布式远程服务调用：也就是我在DSF项目组所做的产品，分布式微服务管理框架。
具备全栈团队运作经验，从设计到开发，再到测试发布拥有全流程工作经验。而且在优秀编码、优秀测试、性能调优以及全流程工程能力建设和效率提升方面有丰富经验。

#基础题
##MySQL的底层数据结构是什么？
MySQL的底层数据结构是B树、B+树

##B+数和红黑树的区别？为啥不用红黑树？如果索引是全内存，不写磁盘B+数还有优势吗？
二叉树、红黑树的树的高度是不限的，并且每个节点只有一条数据,那么要查找某些数据的时候会执行很多次IO
如果索引是全内存就没有优势了，因为磁盘的特点是IO读写比数据读取慢得多，所以需要尽可能减少IO次数来提升效率，同等数据规模下，二叉树比B树的IO次数多得多，如果索引都是内存的话，B树就没有这些优势了，而且会占据更多的内存。

##++i，i++，i += 1，三者有什么区别？（我算法题里面有用到这样的写法，所以估计是顺便问的）
++i和i++在单独使用时是一样的，生成的汇编代码也是一样的。如果是赋值语句，比如“a=++i;”即表示为“i=i+1;a=i;”，同理，“a=i++;”表示为“a=i;i=i+1;”。

#项目相关

##爬取内容相关的问题，碰到什么问题，怎么解决？
创建一个hashmap，对爬取到的内容计算hash值，并保存在hashmap中，下次爬取到内容时，首先在hashmap中找一下是否之前已经爬取过。

##只使用单向链表，做十进制加法

##用一组数来表述连续的柱子的高度，求下雨后，这些柱子能接多少雨水？
如[0,1,0,1,2,1,0,3,1,0]，下雨后，雨水数量为4。黑色为柱子，蓝色为雨水，见附件图

##分布式系统下，如何保证有请求重试的情况下，业务逻辑的正确性，以及解决并发的问题
设计幂等性系统，使用全局唯一ID来实现幂等性。

#二面
##使用面向对象的思路，设计多层，每层有多个电梯的大楼的电梯系统

##域名逆序
如：www.baidu.com -> com.baidu.www

##一个链表a1->a2->a3->...a(n-3)->a(n-2)->a(n-1)->an,对折，后部分逆序和前部分合并。输出a1->an->a2->a(n-1)->a3->a(n-2)->...

##矩阵倾斜输出，给定任意矩阵(m x n):
(0,0),(1,0),(2,0),(3,0)
(0,1),(1,1),(2,1),(3,1)
(0,2),(1,2),(2,2),(3,2)
输出顺序：
(0,0)
(1,0),(0,1)
(2,0),(1,1),(0,2)
(3,0),(2,1),(1,2)
(3,1),(2,2)
(3,2)

##天空中最多的飞机数量。航班时刻表中，每个航班都有在起飞时间和降落时间(不跨天)。航班时刻表数量巨大。给定所有航班起飞和降落时刻
(depTime,arrTime)
求在天上飞行的飞机的数量最多是多少
如：
int foo(List{(9:00,14:00),(8:00,11:00),(18:00,23:00)......})
{
    return 最多多少飞机
}

##解释微信浏览器登录，手机扫描二维码实现浏览器登录微信。具体原理

##设计一个长链转短链的系统

##字符串转32位整数，要求能检测无效字符以及整数溢出
#include <sstream>
int str2int(const char *s){
    /* your code here */
	int num=0;
	stringstream ss;
    ss << res;
    ss >> num;
	return num;
}


##原地反转单链表
例如：1->2->3->4->5->(nil)
变成：5->4->3->2->1->(nil)

struct Node{
    struct Node *next;
    int data;
};

void reverse(struct Node *list){
    /* your code here */
}

##合并有序链表
例如：1->4->5->(nil)
例如：2->3->6->(nil)
变成：1->2->3->4->5->6->(nil)

struct Node{
    struct Node *next;
    int data;
};

struct Node *merge(struct Node *a, struct Node *b){
    /* your code here */
}

##计算某个元素在二叉树中的遍历顺序
例如：
      1
     / \
    2   3
   /\    \
  4  5    6
输入：5
输出：1,2,5

struct Node{
    struct Node *left;
    struct Node *right;
};

void print_path(struct Node *root, int value){
    /* your code here */
}

##求两个等长排序数组的中位数
例如：1,3,5,7,9
以及：2,4,6,8,10
输出：5.5

double get_mid(int *a, int *b, int count){
    /* your code here */
}

##雨水问题
例如：见附件图片
输入：0,1,0,2,1,0,1,3,2,1,2,1
输出：6

##做过的项目及产品详细讲述
项目背景、技术规格、项目难点、解决办法、工作职责

##表达出较强烈的意愿

##薪资
薪资结构及组成，公积金，福利，奖金

##负责对标业内顶级PaaS和SaaS平台的需求研究、技术研究和实现，包括但不限于底层元数据管理、高度灵活的权限管理系统、可扩展的数据存储方案、分布式搜索引擎技术

##负责高质量的设计和编码，承担重点、难点的技术攻坚

##参与产品讨论和开发实现

##计算机相关专业，5年以上后端系统开发经验，有管理经验者优先

##良好的设计和编码品味，热爱写代码，若有代码洁癖更佳
为了降低多线程编程错误,降低对开发人员的技能要求, 提升开发效率,本文档给出一系列的原则：

避免使用信号量，易出错，代码量大，不易维护，建议使用互斥锁和条件变量替代。
必须使用底层同步原语(primitives) 时，只用非递归的互斥器和条件变量，偶尔使用读写锁。
使用高级的并发编程构件，如TaskQueue、CountDownLatch 等等。
只准使用原子锁、互斥锁、条件变量
只能用RAII手法封装mutex/splinlock的创建、销毁、加锁、解锁这四个操作。
只用非递归的mutex（即不可重入的mutex）。
不用读写锁, 使用以下技术来代替读写锁

《七大技术》
技术一：使用智能指针实现多线程下copy-and-write技术----代替读写锁的一种技术
常见场景：多个工作线程来读取一些数据(如缓存服务数据)，一个或多个刷新线程不定期更新数据，为了做到多线程安全的数据刷新和读取,常见的最简单的同步办法是使用读写锁，工作线程加读锁，刷新线程加写锁。

如果刷新数据的时间较长，使用读写锁会导致在刷新数据的时间期间工作线程被阻塞，故使用较智能指针实现多线程下copy-and-write技术。用此技术来代替读写锁。

技术二：使用tr1::function和tr1:bind取代虚函数的技术
function和bind已经纳入了std::tr1，程序设计不应该存在不必要的耦合，而继承是一种比较强的耦合。虚函数限制其使用者必须从某个class派生，绝大部分C++程序库就是这么做，这也是耦合。面向对象三要素是封装、继承和多态。封装是根本，继承和多态已不在是必须。
虚函数用tr1::function和tr1:bind代替，很多OO设计模式，也失去了存在的必要。参见线程池的代码tr1::function和tr1:bind的性能不是很高，DSF统一使用ext_clouser。

技术三：线程安全的对象回调技术
应用场景：如何保证在执行x的成员函数期间，对象x不会在另一个线程被析构，这是C++多线程编程面临的基本问题，也是最容易出现的问题，最难的问题。
如：上层发送消息时，怎么知道IO层对象还活着；IO层收到消息时，回调到上层对象，IO层怎么知道上层对象还活着。
技术挑战：C++要求程序员自已管理对象的生命周期，对象生命周期管理是一个难点，尤其是多线程情况下，尤其困难。
假设一个对象x，一个线程调用x的成员函数时, 怎样保证如下的竞态条件：
1）调用x的成员函数期间，对象x不会被另一个线程析构？
2）在调用x的成员函数之前，如何知道x这个地象还活着？
3) x对象在析构时，怎样保证其它线程没有执行这个x的成员函数？
统一技术方案：一般来说，业界有几种做法：如对象永不释放（如全局变量）；使用对象池；对象延迟释放；不使用这种方式,都在一个线程中调用等。
统一采用如下技术：借助tr1的shared_ptr和weak_prt来完美解决这个线程安全的对象回调技术，代码示意：
class Observable  //not 100% threadsafe!
{
  public:
    void notifyObserver()  //上层的类
    {
      MutexLock lock(mutex_);
      shared_ptr obj(observer_->lock());  
	  //尝试提升，这一步是线程安全的
      if(obj) {
        //提升成功，这说明observer对象是没有被销毁的.
        obj->update();  //这个时候调用obj是安全的，没有竞态条件，因为obj在栈上，对象不可能在本作用域内销毁
      } else {
         //对象已经销毁
         ...
      }
    }
  private:
    tr1::weak_prt<void> observer_;  //io类
    mutableMutex mutex_;
};

技术四：高性能的线程安全的查找表
应用场景：系统中常见根据关键字查找内容的场景，如收到响应消息时，根据消息ID查找消息上下文。
技术挑战：系统要求线程安全，高性能且使用方便。例如标准库中的map可供选择，但是它们是非线程安全的，并且性能不高。
统一技术方案：系统并发库已提供了一个高效的线程安全的查找表，系统所有的模块都使用这个查找表，而不要再去实现一个。
实现原理如下:
通过hash函数将各个key分散到具体的bucket中去，每个bucket带有一个锁，每个bucket又是一个高效的hash_map(tr1::unordered_map), 从而实现线程安全的高并发。

技术五：多线程的任务调度
应用场景：这个是最常见的场景，如IO线程收到消息后，让业务线程处理；如业务要写日志时，使用另外的线程来写日志。
统一技术方案：系统并发库已提供了一个高效ThreadGroup和闭包，所有的模块都使用这个来进行调度。
ThreadGroup和DSF闭包将彻底改变C++程序设计方式。面向继承的(虚函数/多态)的编程将会转换成面向闭包的编程。
实现原理参见:
<TR1新技术将彻底改变C++程序设计方式> (待定)
使用多线程调度，非常简单，只需要两行代码：
void ProcessMsg(MessageImpl*message_impl);  //处理函数
ExtClosure<void()>* fun = NewExtClosure(ProcessMsg, message_impl);  定义闭包函数
dispatcher_->Push(fun);  //多线程调用

技术六：多线程安全的单实例的正确实现方法
//单例实现模板
#include <pthread.h>

template <typename T>

class Singleton
{
    public:
        static T* singleton();
    protected:
        static void InitSingleton()
		{
			pInstance = new T();
		}
		static pthread_once_t _ponce;
		static T* pInstance;
};

template <typename T>
T* Singleton<T>::singleton()
{
    pthread_once(&_ponce, &Singleton<T>::InitSingleton);
    return pInstance;
}

使用方式：
T *p = Singleton<T>::singleton();

技术七：同步等待技术
应用场景：现实生活中常见的场景，如参加一个活动，等人到齐了后一起出发，但是不知道谁先到谁后到。即需要等待某个条件达到要求后才能做后面的事情。如初始化需要启动多个模块，每个模块启动时可能会创建不同的线程作不同的处理逻辑，系统初始化需要等这些模块都初始化正常时才认为是初始化成功。但是系统初始化线程不知道这些模块什么时候才初始化完成。
统一技术方案：为了简化编程，系统并发库已提供提供一个同步辅助类CountDownLatch，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。


####并发编程基本原则
原则1: 进程间通信只能使用sockect。
不使用共享内存，不使用POSIX消息队列，不使用信号量。
注：共享内存收消息时使用停-等方式，和sockect编程中的rector方式不一样,两种通信模式揉合到一个程序里，增加复杂度。加入了'停-等'模式后，会让时延大大提高。做不到1ms时延的要求。

####优秀测试四大原则
原则1：一句话抽象原则(一句话测试声明原则)
这个原则说明的是：测试的最顶层用例必须要抽象成一句话来描述，一行代码一个用例，一个用例必须是一行代码。 
一名话原则的写法：
func Test_ParsePhoneNumber_Basic(t *testing.T) { //正常用例 test_parsePhoneNumber("0086-135-2094-8999", "135209489999", "+86-135-2094-8999") test_parsePhoneNumber("+86-135-2094-8999", "1352094893999", "+86-135-2094-8999") test_parsePhoneNumber("0086-135-2094-8999", "135209438999", "+86-135-2094-8999") test_parsePhoneNumber("086-135-2094-8999", "13520948999", "+86-135-2094-8999") test_parsePhoneNumber("86-135-2094-8999", "13520948999", "+86-135-2094-8999") 
}
原则2：一目了然原则
测试失败了，错误信息要一目了然，信息要能让你容易跟踪并修改bug。


####优秀编码四大原则
原则1：单一抽象层次
一个函数/方法中所有的操作处于相同逻辑层次
原则2：最小化缩进
过分深层的缩进，或者“嵌套”，已经困扰了计算机界达25年之久，而且至今仍然是产生混乱代码的罪魁祸首之一。
NoamChomsky和GeraldWeinberg做过一份研究表明，很少有人能够理解超过3层的嵌套，很多研究人员建议避免使用超过3层的嵌套。
简化复杂的if/else语句，基本就是三个手段：
1.针对头重脚轻的if/else，尽早使用return返回，从而减少嵌套层次
2.合并分支，有些分支持执行的内容相同，可以合并成为一个分支
3.扁平化
原则3：清晰表达式
原则4：善用辅助类拆分
类太大或封装的内容太多, 就拆分它

##动手能力强，喜欢折腾，有解决复杂问题的能力与兴趣

##编程语言不限，若有golang或python经验更佳

##对可扩展性、稳定性、性能、质量有特别的执着，若有高可用性、高性能Web实践经验更佳

##掌握Web后端开发技术：协议、架构、存储、缓存、搜索、安全、消息队列等

##较好的产品意识，关注数据，愿意将产品效果作为工作最重要的驱动因素

##菜鸟教程中的面试经验

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#算法题
##有k个已排序数组，元素可能会重复，求所有元素的中位数和时间复杂度
int selectMid(const vector<vector<int>> &nums)

##跳棋AI设计
##电商促销功能架构设计

#笔试（图片见附件，求能装多少水）
##横平竖直的多边形，求周长K等分点的坐标
##分布式系统下，如果提供服务限流，如短信服务，每分钟，每个服务调用方只能给每个手机发60条短信
##执行抓取任务的时候，任务有时效性，任务异步执行。越新的任务优先级越高。使用redis实现这个任务管理。


##golang的优势
Go语言和C/C++相比，代码更加简洁，抽象能力强，程序健壮性好，并发编程容易，编译速度快，丰富的标准库，但性能稍差，垃圾回收暂停和不确定性。
Go语言和Java相比，代码更加简洁，资源消耗少，但二进制代码可移植性稍差
Go语言和Python相比，性能高，但动态灵活性稍差

Go语言语言特性
1、语法简洁
2、语言级并发
机制：
* 通过Go关键字创建协程
* 通过chan进行协程间通信
* 协程阻塞时自动切换，初始栈小并自动增长
效果：
* 极大简化了并发编程
* 提供了并发系统可靠性，避免了死锁、线程阻塞等并发编程常见问题
* 协程占用资源较小，能够支持多核环境下大规模并发任务同时存在
3、基于组合的面对对象
使用组合代替继承
4、自动的依赖管理
机制：
* 未被使用的依赖视为错误
* 沿依赖关系自底向上编译，间接依赖不会重复编译
* 不允许循环依赖
效果：
* 编译快，大型程序速度是C++的50倍
* 不需要makefile
* 降低了包之间的耦合
5、自带的测试框架
机制：
* 统一了测试文件、测试函数命名规则
* 可运行一个测试函数、测试文件、基准函数、所有函数等
* 性能测试框架支持输出用于性能调优用的CPU和内存相关数据
效果：
* 方便快捷，无需为单元测试安装单独的软件，简化了测试用例的编写
* 灵活，运行"go test"即可方便地进行任何想要的测试
* 基准测试输出的数据，有利于在早期发现性能问题
6、清晰的命名管理
机制：
* 命名大写开头公有，小写私有
* 使用包路径、包名引用代码
* 以别名解决命名冲突
效果：
* 公有私有一目了然，不用再写public、private
* 包名保持简短和清晰，且不必担心命名冲突
* 从语法上就能识别一个名字是否属于某个包，利于IDE精准联想
7、简明统一的语法
8、明确健壮的语意
9、简单清晰的错误处理
通过在多返回值中返回错误来实现错误处理
机制：
* 通过最后一个返回值返回错误类型
* defer防止资源泄露
效果：
* 错误处理代码清晰而简单，不需要特别的控制结构
* 显示地错误检查会迫使程序员在错误出现的时候对错误进行思考并进行相应的处理
* defer能够减少嵌套代码


##重绘和回流的区别
html知识
##Css如何实现垂直水平居中（两种方案）
html知识
##BFC概念理解
BFC是css布局的一个概念，是一块区域，一个环境。
##webpack配置相关(没用过)
webpack是一个模块打包器（module bundler），webpack视HTML，JS，CSS，图片等文件都是一种 资源 ，每个资源文件都是一个模块（module）文件，webpack就是根据每个模块文件之间的依赖关系将所有的模块打包（bundle）起来。

##react当中setState函数执行机制（主要是什么时候会立即改变，什么时候不会）
React 是一个用于构建用户界面的 JAVASCRIPT 库。
##es6 promise回调执行时间
ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。

##对比memcache、redis性能、功能和应用场景
##mysql调优方案

##Raft协议、Paxos、Zap协议的区别。详细描述raft协议
没了解过

##HBase的内部数据存储结构
HBase是一个分布式的、面向列的开源数据库。
大数据内部存储结构
个人设计思路：采用分布式的存储方式，把数据通过负载均衡来存储到各分布式节点上，查找的时候直接把查找任务下发到每个分布式节点上去，若某个节点查找到该数据，则返回查找结果。同时可以在这个基础上再维护一个bitmap，用于保存待查找数据的key值是否在这个分布式存储结构中存在，若存在，再下发查找任务，若不存在，快速返回结果。

##Redis中zset在项目中怎么使用的，zset的实现方式，如果让你来实现一个zset会怎么实现
未使用过redis

##bloom filter实现原理，以及在HBase中的使用
BloomFilter是一个过滤器，他提供了一个轻量级的in-memeory结构，来减少Get操作时读取磁盘文件的数量，只读取包含了要读取的行的文件。能大大的提高读取的效率。

##Kafka在什么情况下会丢失数据，在什么情况下会乱序
Kafka是一个高吞吐量的、持久性的、分布式发布订阅消息系统。
 
##Hadoop中熟悉什么组件，分别介绍一下架构和应用场景

##select id form t where x < 1 and y = 1 and z > 1;这条语句怎么建索引？
##MySQL的事务是什么？什么是事务一致性？
##MySQL的事务隔离有哪些等级？幻读是什么？和不可重读有什么区别？
##ES相关内容，索引，查询，入库
##mysql如何加索引，如何加联合索引
##mysql底层的innodb
##linux开机启动流程
没研究过

