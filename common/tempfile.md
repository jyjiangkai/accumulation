一、性能优化主要分为三个层面：
1、系统层面
数据拷贝（减少消息个数、减少数据拷贝的次数、减少不必要的数据拷贝和传输、简化通信设计

，缩短通信路径、减少交互次数）
内存分配
锁冲突（使用无锁的设计、使用Lock-Free的设计、减少锁的粒度）
上下文切换
缓存
负载均衡
2、算法层面
高效算法替换（HashMap替换stl::map、原子锁替换）
善用cache
正确算法/容器的选择（Map、List、Vector）
3、代码层面
善用缓存
避免临时变量
锁的正确使用（正确使用atomic原子操作、正确使用原子锁）

二、设计
1、识别性能关键路径，针对关键路径进行重点性能设计
针对频繁执行的部分，或对关键性能指标贡献最大的部分重点投入，可以取得最大的效果
2、进行性能分解，确保性能指标被落实
一个性能指标如果涉及到多个模块的配合，那么应该把性能指标分解到每个模块，在精确分解很

困难时，可以利用专家经验进行粗略分解，有一个不太精准的目标，也能提醒开发人员注意性能

问题。
3、简化通信设计，缩短通信路径，减少交互次数
电信系统往往是多单板系统，跨单板和跨进程通信是影响CPU、时延等方面的主要因素，简化流程

，减少消息交互次数，使整个流程经过的单板/进程最少，不仅简化设计，也保证了性能。
4、性能关键路径上，要作数据拷贝最小化设计，禁止进程内性能关键路径的多线程之间的大数据

拷贝
通过传递指针，避免大块内存拷贝可以有效提高性能。String与[]byte的类型转换存在着一次数

据拷贝，一次内存分配，是go的一个隐形性能杀手。
5、性能关键路径需要尽量避免严重的上下文切换
锁和上下文切换都是影响性能和时延的最根本的两个因素。显而易见的，每个人都知道锁和数据

拷贝对性能和时延的影响，但是很多人完全忽略上下文切换对性能和时延的影响。在高负荷下，

上下文切换对性能和时延的影响比数据拷贝大得多。引起上下文切换的第一个因素是：active线

程的个数多于CPU的个数，当active线程的个数/CPU的个数的比例增加了，上下文切换也会增加。

（一般是指数级增长）
6、避免设计集中的耗时处理过程，使CPU占用率处于正常水平
集中的耗时处理长时间占用CPU，使其他同等或低优先级任务无法及时得到调度，影响系统业务提

供和可靠性。
如：由于IO写速度很慢，如果一次性写入大量数据，会导致CPU占有率长时间接近100%，可能造成

任务丢消息、定时器超时、单板复位等问题。可以考虑采用分时写策略，每个周期写一部分数据

从而降低整体CPU占用率。
7、性能关键路径需要尽量避免严重的锁冲突
说明：锁冲突和上下文切换是影响系统性能和时延的最核心的两个因素。很不幸的是，锁的设计

和应用先关，和业务逻辑是紧密耦合。

三、编码规范
1、性能关键路上禁止无谓的memset，尤其是大内存的memset
注：有时候代码不一定是显示的memset，是隐式的，这个尤其要注意。
注：编程归档要求“变量使用之前一定要初始化”，并不表示只要在定义变量时就要初始化，只

是为了防止以后未初始化就引用。
2、性能关键路径避免频繁调用小函数
小函数是比较模糊的概念，小于10行代码的函数可以认为是小函数。在不影响性能的非关键路径

，小函数可以提高代码可读性和可维护性，在关键路径上，小函数的压栈退栈处理消耗比函数本

身功能的消耗要大，采用宏或者把小函数代码展开在调用函数内能够有效提升性能。
修改成小函数使用inline的方式来避免小函数的压栈退栈。
打印语句性能较低，性能关键路径尽量减少打印语句。
3、性能关键路径尽量减少读写CC，硬盘等性能比较低的输入输出操作
说明：对于一定要读写CC和硬盘的，可以考虑把内容写到缓存里面，每5秒钟写一次硬盘，或者没

写100个缓存，写一次硬盘等，可以大大优化性能指标。
4、性能关键路径尽量避免向操作系统动态申请和释放内存
操作系统申请和释放内存性能比较低，如果使用的内存大小比较固定，使用频率高，可以按照常

用内存大小预先申请号，避免向操作系统频繁申请和释放。或者用全局变量的方式来替代动态申

请内存。全局变量会放在目标文件的数据段，如果全局变量太多会造成目标文件过大，使用全局

变量要注意这点。
5、性能关键路径多条件判断场景，要把概念大的判断放在前面
说明：如果在并列的switch-case的很多条件里面，其中一个条件的命中概念很大，甚至是90%以

上，可以把这个条件抽出switch-case，在switch-case前面用if判断，在else分支使用switch-

case判断余下条件，这样可以保证大多数情况下一个判断就命中。有些CPU有预测分支的机制，对

于一个if-else而言，会把if条件下面的指令预测为概率较高优先载入，如果运行中if条件不成立

，需要重新载入else下面的指令，这也是造成性能差异的原因。
6、频繁使用的比较固定的数据不要每次都计算，计算一次保存结果供后续直接使用
说明：在软件初始化的时候把能够固定的数据都计算好保存下来，以后需要使用的时候就不要计算了。对于C++来说，如果对象能够在初始化的时候生成，就不必在处理过程中动态生成和销毁。
7、性能关键路径尽量避免临时对象的产生。
说明：对象的创建和销毁操作对程序的性能有很大的影响。值得注意的是,编译器会在某些情况下生成隐式的临时对象。这些对象并不出现在源码级别。一般注意如下两种场景:（1）函数返回一个对象,或传值方式而导致临时对象的产生；（2）实际调用函数时传入的参数与函数定义中声明的变量类型不匹配。
这个在GO DSF 中对字符串的参数比较多见如:对于函数的参数是const string&类型，而调用者传递的是 const char * 类型。
8、避免使用大的结构作为函数的输入参数，用指针或引用替代。
9、性能关键路（如session池,AVP参数池复用初始化时）禁止调用不必要的高性能消耗的内部函数如bind_to_object(),bind_to_object_cstr(),findService()等。
10、性能关键路径（如session池,AVP参数池复用初始化时）禁止调用不必要的高性能消耗的系统函数如memset(), gettimeofday()等。
11、性能关键路径（信令级别/IDL级别）禁止使用 ENIP::TString /STL::String作为接口,使用ENIP::String 替代或使用char*的方式。
12、性能关键路径（信令级别/IDL级别）上,考虑使用Hash Map或数组取代MAP。当遍历不需要考虑顺序时，可以使用HashMap替换MAP来提高性能。
13、性能关键路径（信令级别/IDL级别）禁止使用定长的sequence（bounded_sequence）,使用无长度的sequence替代。
定长sequence 序列化时是一个字节一字节拷贝,效率很差。
sequence <TChar> 和sequence<TOctet> 序列化时是一次拷贝而不是一个字节一个字节的拷贝,因此效率相对高一些。
14、定义物理表时,使用NUMBER(10,0)类型来替代INTEGER/SMALLINT类型。
Oracle后台会把INTEGER/INT/SMALLINT完成映射至NUMBER(38,0)类型,对于4字节整形,其最大值为4294967295, 10位已足够了, NUMBER(38,0) 比NUMBER(10,0)会多占用存贮空间和性能
15、性能关键路径需要尽量避免严重的锁冲突
说明：锁冲突和上下文切换是影响系统性能和时延的最核心的两个因素。很不幸的是,锁的设计和应用相关,和业务逻辑紧密藕合，本规范只能给出一些关于锁设计的思路。
高效的锁方案是非常难于设计的,这是个进退两难的问题,细粒度的锁,锁冲突很少，性能高，但是细粒度锁编程复杂，容易出错，容易导致死锁或活锁;但是粗粒度的锁又会导致有锁冲突性能时延下降。在实际编程中，我们往往需要从编程复杂度、性能等多个方面来权衡自己的设计方案。但是怎样权衡,怎样做到既高效又正确的锁？
首先要做的是建立一个锁的地图,这个地图有两个轴:
纵轴描述你的代码:各分层的模块,如OSI-model 7 层协议模型.
横轴描述你的数据:需要锁的共享资源的数据集
这样你就有一个格栅，如下图所示。
设计的目标是确保尽可能把锁在两个轴中平均地分配.不幸的是，这是和应用非常相关的。最重要的是以下规则:
两个请求（两个消息）不应该有锁冲突（contention），除非它们在同一个数据集和同一层中。
怎样分割,怎样找到层(模块)和共离数据集之间的分开线?这里面由于和应用非常相关,本文档只提供一个案例 （在50ms 时延攻关过程中, SCS/stack通过分割数据修改后,时延整体降低了16 ms, 效果明显)
一般来说分割数据集的建议:
16、如消息（请求）和事务ID,sessionID,序列号等有关联, 建议按照号段来分割数据集。
SCS 和 协议栈总享一个数据集 ---- 一个map表,key 为 sessionID, value 为一个Call对象.
1.	协议栈在创建一个新的呼叫(Call)时,把Call对象插入到此map表中,key为此对象的sessionID.
2.	协议栈在收到消息,根据sessionID查找此对象,找到对象后,把消息转给此对象处理.
3.	SCS线程中呼叫结束时,把此对象从map表中删除。
由于SCS线程,stack线程都访问这个共享数据.
从这看出,当SCS在一个呼叫结束时,stack 不能处理所有的其它的呼叫的消息。这有严重的锁冲突。
修改：数据集按SessionID分拆成16个数据集,这样的锁冲突就很少了, 当一个SCS在处理一个消息时, 大约有93%(15/16)的其它呼叫的消息可以被stack处理，这样的锁冲突就大大减少了。
17、性能关键路径需要尽量避免严重的上下文切换。
说明:锁和上下文切换都是影响性能和时延的最根本的两个因素。显而易见的，每个人都知道锁和数据拷贝对性能和时延的影响, 但是很多在完全忽略上下文切换对性能和时延的影响。
在高负荷下,上下文切换对性能和时延的影响比’数据拷贝’大得多。
引起上下文切换的第一个因素是:active 线程的个数多于CPU的个数.当active线程的个数/CPU的个数的比例增加了, 上下文切换也会增加.(一般是指数的影响). 
这也是为什么所有的高效的服务器都不采用一个连接一个线程的原因,因为它的伸缩性非常差。
18、非性能瓶颈线程不能分析成多个线程. 这对提升性能和时延都无意义。
19、主工作线程(性能瓶颈线程)不能有任何的sleep,禁止主工作线程在没有消息时调用sleep
注:启动初始化时,双机切换时除外
注：非主线程(性能瓶颈线程),接收线程,可以除外。
GO DSF 有一些组件(包括ENIPCore), 使用轮询的方式来检查是否有消息到来,如果消息队列中有消息,则处理消息,如果消息队列中没有消息，则sleep(Nms)，这样会造成线程等待时延和busy-loop问题。绝大部分高效的服务器编程中都不会使用这种轮询的方式来检查是否有消息或者是检查是否某个 non-blocking IO 操作是否完成。
使用非sleep的方案改造方案一般都是使用FIFO 或 unix socket pair写一个字节通知的方式, 工作线程采用基于在“non-blocking IO + IO multiplexing”,这种模型下，程序的基本结构大致如下: （没有消息时,系统处于select/poll等待中,一旦有消息,系统能够立即处理消息。
20、简化通信设计，缩短通信路径，减少交互次数
提升时延可以分析业务流程,看否能够减少不必要的消息,否能减少不必要的交互, 否能可以并行等。




GODSF性能调优总结
1.日志修改成异步(当前只有一个协程在处理日志,需要考虑channel满时的异常处理，看是否会引起死锁)
2.从md中取traceFlag 只取一次,不用在每个函数中都取,函数之间通过参数传递traceFlag.
3.写日志优化,日志字符串使用值传递修改成指针传递
4.Foundation写debug日志比较耗时，debug日志没有开启时,没有立即返回
5.在没有日志跟踪任务时,立即返回,不再处理复杂的逻辑.
6.GLS 一个大锁修改成使用16把锁
7.使用perfmap代替concurrentmap
8.写日志时，拼写参数时,使用buffer复用,不需要每次都构造buffer


RPC--远程过程调用
远程过程调用是一个计算机通信协议，该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。
RPC是进程间的通讯方式，不用的进程有不同的地址空间。如果client和sever在同一台机器上，尽管物理地址是相同的，但是虚拟地址空间不同。如果他们在不同的主机上，物理地址空间也不同。

一个正常的RPC过程可以分成下面几步： 
1. client调用client stub，这是一次本地过程调用 
2. client stub将参数打包成一个消息，然后发送这个消息。打包过程也叫做marshalling 
3. client所在的系统将消息发送给server
4. server的的系统将收到的包传给server stub 
5. server stub解包得到参数。 解包也被称作unmarshalling 
6. 最后server stub调用服务过程. 返回结果按照相反的步骤传给client


https://blog.csdn.net/b1303110335/article/details/79557292
https://blog.csdn.net/wangyunpeng0319/article/details/78651998


