##深入理解计算机系统

####总结1
总线：贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。

####总结2
I/O设备：I/O(输入/输出)设备是系统与外部世界的联系通道。我们的示例系统包括四个I/O设备：作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器(简单地说就是磁盘)。

####总结3
并发和并行：我们用的术语并发是一个通用的概念，指一个同时具有多个活动的系统；而术语并行指的是用并发来使一个系统运行的更快。

####总结4
超线程：有时称为同时多线程，是一项允许一个CPU执行多个控制流的技术。

####总结5
如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为超标量处理器。大多数现代处理器都支持超标量操作。

####总结6
进程的虚拟地址空间：
	内核
	栈
	共享库
	堆
0	代码和数据

####总结7
当程序用如下伪指令编译后，该程序可以在32位或者64位的机器上正确运行。
linux> gcc -m32 main.c
当程序用如下伪指令编译后，该程序就只能在64位的机器上正确运行。
linux> gcc -m64 main.c
大多数64位机器也可以运行为32位机器编译的程序，这是一种向后兼容。
我们将程序称为“32位程序”或“64位程序”时，区别在于该程序是如何编译的，而不是其运行的机器类型。

####总结8
某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。前一种规则--最低有效字节在最前面的方式，称为小端法。后一种规则--最高有效字节在最前面的方式，称为大端法。
假设变量x的类型为int，位于地址0x100处，它的十六进制值为0x01234567。地址范围0x100~0x103的字节顺序依赖于机器的类型：
大端法：
       0x100 0x101 0x102 0x103
| ... | 01  | 23  | 45  | 67  | ... |
小端法：
	   0x100 0x101 0x102 0x103
| ... | 67  | 45  | 23  | 01  | ... |

####总结9
几乎所有的编译器/机器组合都对有符号数使用算术右移，且许多程序员也都假设机器会使用这种右移。另一方面，对于无符号数，右移必须是逻辑的。

####总结10
两个指针可能指向同一个内存位置的情况称为内存别名使用。

####总结11
在实际的处理器中，是同时对多条指令求值的，这个现象称为指令级并行。

####总结12
链接是将各种代码和数据片段收集并组合称为一个单一文件的过程，这个文件可被加载(复制)到内存并执行。

####总结13
GCC编译链接过程：
linux> gcc -Og -o prog main.c sum.c
上述行为包括了从源文件翻译成可执行目标文件的过程，具体步骤如下：
首先，将C的源文件翻译成一个ASCII码的中间文件main.i
cpp main.c /tmp/main.i
接下来，驱动程序运行C编译器(cc1)，它将main.i翻译成一个ASCII汇编语言文件main.s
cc1 /tmp/main.i -Og -o /tmp/main.s
然后，驱动程序运行汇编器(as)，它将main.s翻译成一个可重定位目标文件main.o
as -o /tmp/main.s /tmp/main.o
最后，它运行链接器程序ld，将main.o以及一些必要的系统目标文件组合起来，创建一个可执行目标文件prog
ld -o prog /tmp/main.o
要运行可执行文件prog，我们在Linux shell的命令行上输入它的名字
linux> ./prog

####总结14
典型的ELF可重定位目标文件：
ELF头
.text
.rodata
.data
.bss
.symtab
.rel.text
.rel.data
.debug
.line
.strtab
节头部表

.text：已编译程序的机器代码
.rodata：只读数据
.data:已初始化的全局和静态C变量
.bss：未初始化的全局和静态C变量
.symtab:一个符号表，它存放在程序中定义和应用的函数和全局变量的信息
.rel.text:一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些配置
.debug:一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。
.line:原始C源程序中的行号和.text节中机器指令之间的映射。
.strtab:一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。

####总结15
创建静态库
linux> gcc -c addvec.c multvec.c
linux> ar rcs libvector.a addvec.o multvec.o

####总结16
使用静态库
linux> gcc -c main2.c
linux> gcc -static -o prog2c main2.o ./libvector.a
或者等价于
linux> gcc -c main2.c
linux> gcc -static -o prog2c main2.o -L. -lvector

####总结17
关于库的一般准则是将它们放在命令行的结尾。另一方面，如果库不是相互独立的，那么必须对它们排序，使得对于每个被存档的文件的成员外部引用的符号s，在命令行中至少有一个s的定义是在对s的引用之后的。如果需要满足依赖需求，可以在命令行上重复库。

####总结18
每个Linux程序都有一个运行时内存映像。在Linux x86-64系统中，代码段总是从地址0x400000处开始，后面是数据段。运行时堆在数据段之后，通过调用malloc库往上增长。堆后面的区域是为共享模块保留的。用户栈总是从最大的合法用户地址(2^48 - 1)开始，向较小内存地址增长。栈上的区域，从地址2^48开始，是为内核中的代码和数据保留的，所谓的内核就是操作系统驻留在内存的部分。

####总结19
创建动态库
linux> gcc -shared -fpic -o libvector.so addvec.c multvec.c
-fpic选项指示编译器生成与位置无关的代码。-shared选项指示链接器创建一个共享的目标文件。

####总结20
使用动态库
linux> gcc -o prog21 main2.c ./libvector.so

####总结21
可以加载而无需重定位的代码称为位置无关代码。用户对GCC使用-fpic选项指示GNU编译系统生成PIC代码。共享的编译必须总是使用该选项。

####总结22
编译时打桩
linux> gcc -DCOMPILETIME -c mymalloc.c
linux> gcc -I. -o intc int.c mymalloc.o
由于有-I.参数，所以会进行打桩，它告诉C预处理器在搜索通常的系统目录之前，先在当前目录中查找malloc.h。注意，mymalloc.c中的包装函数是使用标准malloc.h头文件进行编译的。
运行这个程序会得到如下的追踪信息：
linux> ./intc
malloc(32)=0x9ee010
free(0x9ee010)

####总结23
链接时打桩
linux> gcc -DLINKTIME -c mymalloc.c
linux> gcc -c int.c
然后把目标文件链接成可执行文件：
linux> gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o

####总结24
运行时打桩
编译时打桩需要能够访问程序的源代码，链接时打桩需要能够访问程序的可重定位对象文件。不过，有一种机制能够在运行时打桩，它只需要能够访问可执行目标文件。这个很厉害的机制基于动态链接器的LD_PRELOAD环境变量。
如果LD_PRELOAD环境变量被设置成一个共享路径名的列表(以空格或分号分隔)，那么当你加载和执行一个程序，需要解析未定义的引用时，动态链接器(LD-LINUX.SO)会先搜索LD_PRELOAD库，然后才搜索任何其他的库。
linux> gcc -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl
linux> gcc -o intr int.c
运行：
linux> LD_PRELOAD="./mymalloc.so" ./intc
malloc(32)=0x1bf7010
free(0x1bf7010)

####总结25
处理目标文件的工具
在Linux系统中有大量可用的工具可以帮助你理解和处理目标文件。特别地，GNU binutils包尤其有帮助，而且可以运行在每个Linux平台上。
*AR：创建静态库，插入、删除、列出和提取成员。
*STRINGS：列出一个目标文件中所有可打印的字符串。
*STRIP：从目标文件中删除符号表信息。
*NM：列出一个目标文件的符号表中定义的符号。
*SIZE：列出目标文件中节的名字和大小。
*READELF：显示一个目标文件的完整结构，包括ELF头中编码的所有信息。包含SIZE和MN的功能。
*OBJDUMP：所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编.text节中的二进制命令。
Linux系统为操作共享库还提供了LDD程序：
*LDD：列出一个可执行文件在运行时所需要的共享库。

####总结26
Linux/x86-64故障和终止
除法错误：当应用试图除以零时，或者当一个除法指令的结果对于目标操作数来说太大了的时候，就会发生除法错误(异常0)。Unix不会试图从除法错误中恢复，而是选择终止程序。Linux shell通常会把除法错误报告为“浮点异常(Floating exception)”。
一般保护故障：许多原因都会导致不为人知的一般保护故障(异常13)，通常是因为一个程序引用了一个未定义的虚拟内存区域，或者因为程序试图写一个只读的文本段。Linux不会尝试恢复这类故障。Linux shell通常会把这种一般保护故障报告为“段故障(Segmentation fault)”。

####总结27
逻辑控制流
进程为每个程序提供了一种假象，好像程序在独占地使用处理器。关键点在于进程是轮流使用处理器的。每个进程执行它的流的一部分，然后被枪占(preempted)(暂时挂起)，然后轮到其他进程。

####总结28
并发流
一个逻辑流的执行在时间上与另一个重叠，称为并发流，这两个流被称为并发的运行。
多个流并发地执行的一般现象被称为并发。一个进程和其他进程轮流运行的概念称为多任务。一个进程执行它的控制流的一部分的每一时间段叫做时间片。因此，多任务也叫做时间分片。
如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为并行流，它们并行的运行，且并行地执行。

####总结29
处理器通常是用某个控制寄存器中的一个模式位来提供这种功能的，该寄存器描述了进程当前享有的特权。

####总结30
操作系统内核使用的一种称为上下文切换的较高层形式的异常控制流来实现多任务。
内核为每个进程维持一个上下文。上下文就是内核重新启动一个被抢占的进程所需要的状态。
上下文切换：(1)保存当前进程的上下文，(2)恢复某个先前被抢占的进程被保存的上下文，(3)将控制传递给这个新恢复的进程。

####总结31
将错误处理函数封装，使代码整洁
	pid_t Fork(void)
	{
		pid_t pid;
		if ((pid == fork()) < 0)
		{
			unix_error("Fork error");
		}
		return pid;
	}
给定这个包装函数，我们对fork的调用就缩减为1行：
	pid = Fork();

####总结32
回收子进程
当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从此时开始，该进程就不存在了。一个终止了但还未被回收的进程称为僵死进程。

####总结33
让进程休眠
sleep函数将一个进程挂起一段指定的时间。
	#include <inistd.h>
	unsigned int sleep(unsigned int secs);
如果请求的时间量已经到了，sleep返回0，否则返回还剩下的要休眠的秒数。后一种情况是可能的，如果因为sleep函数被一个信号中断而过早地返回。
我们会发现另一个很有用的额函数是pause函数，该函数让调用函数休眠，直到该进程收到一个信号。
	#include <inistd.h>
	int pause(void);

####总结34
Linux提供阻塞信号的隐式和显式的机制：
隐式阻塞机制：内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。
显式阻塞机制：应用程序可以使用sigprocmask函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。

####总结35
编写处理程序的原则：
(1)处理程序要尽可能简单
(2)在处理程序中只调用异步信号安全的函数
(3)保存和恢复errno
(4)阻塞所有的信号，保护对共享全局数据结构的访问
(5)用volatile声明全局变量
(6)用sig_atomic_t声明标志

####总结36
虚拟内存提供了三个重要的能力：(1)它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。(2)它为每个进程提供了一致的地址空间，从而简化了内存管理。(3)它保护了每个进程的地址空间不被其他进程破坏。

####总结37
物理和虚拟寻址
计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每个字节都有一个唯一的物理地址。第一个字节的地址为0，接下来的字节地址为1，再下一个为2，以此类推。给定这种简单的结构，CPU访问内存的最自然的方式就是使用物理地址。我们把这种方式称为物理寻址。
使用虚拟寻址，CPU通过生成一个虚拟地址来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译。

####总结38
地址空间是一个非负整数地址的有序集合。

####总结39
WAN:广域网，之所以这个叫是因为它们覆盖的地理范围比局域网大。

####总结40
互联网协议必须提供两种基本能力：
命名机制。每台主机会被分配至少一个这种互联网络地址，这个地址唯一的标识了这台主机。(主机IP)
传送机制。互联网络协议通过定义一种把数据位捆扎成不连续的片(称为包)的统一方式，从而消除了这些差异。一个包是由包头和有效载荷组成的，其中包头包括包的大小以及源主机和目的主机的地址，有效载荷包括从源主机发出的数据位。(发包)

####总结41
TCP/IP实际是一个协议族，其中每一个都提供不同的功能。例如，IP协议提供基本的命名方法和递送机制，这种递送机制能够从一台因特网主机往其他主机发送包，也叫做数据报。IP机制从某种意义上而言是不可靠的，因为，如果数据报在网络中丢失或者重复，它并不会恢复。UDP稍微扩展了IP协议，这样一来，包可以在进程间而不是在主机间传送。TCP是一个构建在IP之上的复杂协议，提供了进程间可靠的全双工连接。

####总结42
IPv4和IPv6
最初的因特网协议，使用32位地址，称为因特网协议版本4。1996年，因特网工程任务组织提出了一个新版本的IP，称为因特网协议版本6，它使用的是128位地址，意在替代IPv4。

####总结43
DNS：域名系统

