闭包（closure）也是很常见的编码模式，因它隐式携带上下文环境变量，因此可让算法代码变得更加简洁。
但任何 “便利” 和 “优雅” 的背后，往往都是更复杂的实现机制，无非是语法糖或编译器隐藏了相关细节。最终，这些都会变成额外成本在运行期由 CPU、runtime 负担。甚至因不合理使用，造成性能问题。

首先，闭包引用原环境变量，导致 y 逃逸到堆上，这必然增加了 GC 扫描和回收对象的数量。
接下来，同样是因为闭包引用原对象，造成数据竞争（data race）。
可见，闭包未必总能将事情 “简单化”。在学习 Go 底层实现过程中，你会了解到，所有 “简单” 都是由编译器或运行时用一堆复杂过程堆出来的。
